// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Sin.cs" company="">
//   
// </copyright>
// <summary>
//   The base class for all types that act as an input/output conduit for the
//   brain: Sensory interfaces.
// </summary>
// --------------------------------------------------------------------------------------------------------------------
namespace JaStDev.HAB
{
    /// <summary>
    ///     The base class for all types that act as an input/output conduit for the
    ///     brain: Sensory interfaces.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Examples of specific sensory interfaces are: TextSin, for processing
    ///         ascii text or <see cref="GUISin" /> for handling GUI automations.
    ///     </para>
    ///     <para>
    ///         Descendents of this class can possibly also use the
    ///         <see cref="NeuronIDAttribute" /> to preload one 1 or more instances of
    ///         the Sin. It is also possible that applications preload this just after
    ///         instantiating the <see cref="Brain" /> .
    ///     </para>
    ///     <para>
    ///         This class inherits from <see cref="TextNeuron" /> so that it is possible
    ///         to easely attach a name to the Sin.
    ///     </para>
    ///     <para>
    ///         descendents can perform extra things when the sin gets deleted in the
    ///         <see cref="sin.CallSinDestroyEvent" />
    ///     </para>
    /// </remarks>
    [NeuronID((ulong)PredefinedNeurons.EntryPoints, typeof(Neuron))]
    [NeuronID((ulong)PredefinedNeurons.EntryPointsCreated, typeof(Neuron))]
    [NeuronID((ulong)PredefinedNeurons.ActionsForInput, typeof(Neuron))]
    public abstract class Sin : TextNeuron, IStoragePropertiesUser
    {
        #region ActionsForInput

        /// <summary>
        ///     Gets/sets the cluster to assign to data generated by the sin for
        ///     solving. This is also used by <see cref="Query" /> sins to store the
        ///     code that they need to execute.
        /// </summary>
        /// <remarks>
        /// </remarks>
        public NeuronCluster ActionsForInput
        {
            get
            {
                return FindFirstOut((ulong)PredefinedNeurons.ActionsForInput) as NeuronCluster;
            }

            set
            {
                SetFirstOutgoingLinkTo((ulong)PredefinedNeurons.ActionsForInput, value);
            }
        }

        #endregion

        #region IStoragePropertiesUser Members

        /// <summary>Rerturns the type of the specified property. This is used so we can
        ///     read all the property types from the storage at once for converting
        ///     storage type.</summary>
        /// <remarks>Since this sin doesn't have any properties, nothing is returned.</remarks>
        /// <param name="name">The name.</param>
        /// <returns>The <see cref="Type"/>.</returns>
        public virtual System.Type GetTypeForProperty(string name)
        {
            return null;
        }

        #endregion

        /// <summary>Tries to translate the specified neuron to the output type of the<see cref="Sin"/> and send it to the outside world.</summary>
        /// <param name="toSend">The to Send.</param>
        /// <remarks><para>How it does the output and in which form is completely dependent on
        ///         the implementation of the Sin. Most often though, some sort of event
        ///         is used.</para>
        /// <para>This method is called by the <see cref="Brain"/> itself during/after
        ///         processing of input.</para>
        /// </remarks>
        public abstract void Output(System.Collections.Generic.IList<Neuron> toSend);

        /// <summary>
        ///     Called when the data needs to be saved.
        /// </summary>
        public abstract void Flush();

        /// <summary>
        ///     Called when all the data of the sensory <see langword="interface" />
        ///     needs to be loaded into memory.
        /// </summary>
        /// <remarks>
        ///     By default, doesn't do anything. Not all sins require extra
        ///     information.
        /// </remarks>
        public virtual void TouchMem()
        {
        }

        /// <summary>
        ///     Calls the sin activity event, if there is any code.
        /// </summary>
        private void CallSinActivityEvent()
        {
            if (Settings.RaiseNetworkEvents)
            {
                try
                {
                    var iCluster = Brain.Current[(ulong)PredefinedNeurons.OnSinActivity] as NeuronCluster;
                    if (iCluster != null)
                    {
                        using (var iList = iCluster.Children)
                            if (iList.Count > 0)
                            {
                                var iProc = ProcessorFactory.GetProcessor();
                                iProc.CurrentSin = this;
                                iProc.CallSingle(iCluster);
                            }
                    }
                }
                catch (System.Exception e)
                {
                    LogService.Log.LogError("Sin.CallSinActivityEvent", e.ToString());
                }
            }
        }

        /// <summary>The call sin create event.</summary>
        public void CallSinCreateEvent()
        {
            if (Settings.RaiseNetworkEvents)
            {
                try
                {
                    var iCluster = Brain.Current[(ulong)PredefinedNeurons.OnSinCreated] as NeuronCluster;
                    if (iCluster != null)
                    {
                        using (var iList = iCluster.Children)
                            if (iList.Count > 0)
                            {
                                var iProc = ProcessorFactory.GetProcessor();
                                iProc.CurrentSin = this;
                                iProc.CallSingle(iCluster);
                            }
                    }
                }
                catch (System.Exception e)
                {
                    LogService.Log.LogError("Sin.CallSinActivityEvent", e.ToString());
                }
            }
        }

        /// <summary>
        ///     Calls the session stop event. Happens when the sin gets deleted from
        ///     the network. This is for dynamic sins like text channels.
        /// </summary>
        public virtual void CallSinDestroyEvent()
        {
            if (Settings.RaiseNetworkEvents)
            {
                try
                {
                    var iCluster = Brain.Current[(ulong)PredefinedNeurons.OnSinDestroyed] as NeuronCluster;
                    if (iCluster != null)
                    {
                        using (var iList = iCluster.Children)
                            if (iList.Count > 0)
                            {
                                var iSignal = new System.Threading.ManualResetEvent(false);
                                var iProc = ProcessorFactory.GetProcessor();
                                iProc.CurrentSin = this;
                                iProc.TreeFinished = () => iSignal.Set();
                                
                                iProc.CallSingle(iCluster);
                                iSignal.WaitOne();

                                    // we wait until the callback is finished, if we don't do this, the sin gets deleted before we call the code, which doesn't work.
                            }
                    }
                }
                catch (System.Exception e)
                {
                    LogService.Log.LogError("Sin.CallSinActivityEvent", e.ToString());
                }
            }
        }

        /// <summary>Processes the specified neuron.</summary>
        /// <remarks>This function makes certain that the <paramref name="processor"/> gets
        ///     a reference to the sin that sent it to the brain + it copies over the<see cref="JaStDev.HAB.Neuron.ActionsCluster"/> of the sin to the
        ///     item to process (if there is any).</remarks>
        /// <param name="toProcess">The neuron to process.</param>
        /// <param name="processor">The processor to use</param>
        /// <param name="logText">The log text that should be displayd if info logging is enabled.</param>
        protected void Process(Neuron toProcess, Processor processor, string logText)
        {
            CallSinActivityEvent();
            processor.CurrentSin = this;
            processor.Push(toProcess);
            toProcess.ActionsCluster = ActionsForInput;

                // we copy over the actions cluster so that the neuron to solve will get the same as that of the sin.
            processor.Solve();
            if (Settings.LogLevel > 0)
            {
                LogService.Log.LogInfo(
                    "Sin.Process", 
                    string.Format("Successfully initiated impuls for value: {0}.", logText));
            }
        }

        /// <summary>The process call.</summary>
        /// <param name="toCall">The to call.</param>
        /// <param name="processor">The processor.</param>
        /// <param name="logText">The log text.</param>
        protected void ProcessCall(NeuronCluster toCall, Processor processor, string logText)
        {
            CallSinActivityEvent();
            processor.CurrentSin = this;
            processor.CallSingle(toCall);
            if (Settings.LogLevel > 0)
            {
                LogService.Log.LogInfo(
                    "Sin.Process", 
                    string.Format("Successfully initiated impuls for value: {0}.", logText));
            }
        }

        /// <summary>Processes the list of neurons. The first item in the list will be
        ///     processed last.</summary>
        /// <remarks>This function makes certain that the <paramref name="processor"/> gets
        ///     a reference to the sin that sent it to the brain + it copies over the<see cref="JaStDev.HAB.Neuron.ActionsCluster"/> of the sin to each
        ///     item to process (if there are any).</remarks>
        /// <param name="toProcess">The neuron to process.</param>
        /// <param name="processor">The processor to use</param>
        /// <param name="logText">The log text that should be displayd if info logging is enabled.</param>
        protected void Process(System.Collections.Generic.IEnumerable<Neuron> toProcess, 
            Processor processor, 
            string logText)
        {
            CallSinActivityEvent();
            processor.CurrentSin = this;
            foreach (var i in toProcess)
            {
                processor.Push(i);
                i.ActionsCluster = ActionsForInput;

                    // we copy over the actions cluster so that the neuron to solve will get the same as that of the sin.
            }

            processor.Solve();
            if (Settings.LogLevel > 0)
            {
                LogService.Log.LogInfo(
                    "Sin.Process", 
                    string.Format("Successfully initiated impuls for value: {0}.", logText));
            }
        }

        /// <summary>
        ///     Creates an exact duplicate of this <see cref="Neuron" /> so the
        ///     <see cref="Processor" /> can perform a split.
        /// </summary>
        /// <remarks>
        ///     A new id is created for the neuron cause all neurons should have
        ///     unique numbers.
        /// </remarks>
        /// <returns>
        ///     An exact duplicate of the argument, but with a new id.
        /// </returns>
        public override Neuron Duplicate()
        {
            throw new BrainException("Sins can't be duplicated");
        }
    }
}
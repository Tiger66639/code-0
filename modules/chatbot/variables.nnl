class Variables
{
   using PathCommon;
   using common;

   Variable varcount {}                      //this var is shared among the variable calculations.   
   Neuron AttachedTopics;                    //identifies topics that have been attached to input/output statements.
   
   
   //variables are bound to the $ operator. 
   bind $ BindVar register                                            //let the compiler know that this binding needs to be registered so that it can be used for binding variables by other parts of the system, like output patterns.
   {  
      
      var fCurrentVar;                                               //keeps track of the cluster containing the current var data, so we can do a 'getText' -> index is attached to cluster
      
      //not really needed anymore
      //entry point for set operations. required cause we need to store a reference to the code path
      //itself. This is required cause it can potentially have an extra link to indicate that it should get
      //the var value from a thesaurus path (so an object, othrewise a text or compound is always used).
      this(var toCall)
      {
         call(toCall);
      }
      
      //not really needed anymore
      //entry point for get operations. required cause we need to store a reference to the code path
      //itself. This is required cause it can potentially have an extra link to indicate that it should get
      //the var value from a thesaurus path (so an object, othrewise a text or compound is always used).
      this(var toCall): var
      {
         call(toCall);
         //don't return a value, this is done in the 'call', as long as it doesn't get consumed,
         //it remains on the stack.
      }
      
      //ex: $PrevOut(1)  returns the previous output statement (not the one currently being built).
      //the index determins how many statements the system must go back.
      PrevOut(int index): var
      {
         int iIndex = index;                                                        //we make a local copy of the index value. If we don't do this, we will change the original value (passed along as 'byRef', not a copy)
         var iLogItem;
         var log = GetFirstOut(outputsin, PatternMatcher.currentconversation);
         for(int iPos = ChildCount(log) -1; iPos >= 0; iPos--)
         {
            iLogItem = GetChildAt(log, iPos);
            if(GetClusterMeaning(iLogItem) == Statics.Out)
            {
               iIndex--;                                                          //do before, cause the current statement isn't logged yet
               if(iIndex == 0)
               {
                  var iRes = GetChildren(iLogItem);
                  if(GetClusterMeaning(GetLast(iRes)) == ref(Statics.Time))            //if we don't do ref(Time), we get the actual time, but we need to check of the clustermeaning == the 'time' var.
                     RemoveAt(iRes, ChildCount(iLogItem) -1);                        //the output can also log the date-time stamp which we need to remove. It is added at the end, so remove the last item on the list before returning the result.
                  return iRes;
               }
            }
         }
         return;                                                                 //nothing found, so return empty result.
      }
      
      //ex: $PrevIn(1)  returns the previous input statement (not the current).
      //the index determins how many statements the system must go back.
      //to get the current input, do $input(0)
      PrevIn(int index): var
      {
         int iIndex = index;                                                        //we make a local copy of the index value. If we don't do this, we will change the original value (passed along as 'byRef', not a copy)
         var iLogItem;
         var log = GetFirstOut(outputsin, PatternMatcher.currentconversation);
         for(int iPos = ChildCount(log) -1; iPos >= 0; iPos--)
         {
            iLogItem = GetChildAt(log, iPos);
            if(GetClusterMeaning(iLogItem) == Statics.In)
            {
               if(iIndex == 0)
               {
                  var iRes = GetChildren(iLogItem);
                  RemoveAt(iRes, ChildCount(iLogItem) -1);                          //the input also logs the date-time stamp which we need to remove. It is added at the end, so remove the last item on the list before returning the result.
                  return iRes;
               }
               else
                  iIndex--;
            }
         }
         return;                                                                 //nothing found, so return empty result.
      }
      

      /*
        makes certain that the first letter of the words passed in as input, are in upper case.
       */
      ucase(var callbackin): var
      {
         var interleafwith = Statics.FirstUppercase;
         return Statics.FirstUppercase, Interleaf(ref(callbackin), ref(interleafwith));
      }
      /*
        makes certain that al the letters of the words passed in as input, are in upper case.
       */
      allucase(var callbackin): var
      {
         var interleafwith = Statics.AllUpperCase;
         return Statics.AllUpperCase, Interleaf(ref(callbackin), ref(interleafwith));
      }
      
      /*
        makes certain that al the letters of the words passed in as input, are in lower case.
       */ 
      AllLCase(var callbackin): var
      {
         var interleafwith = Statics.AllLowerCase;
         return Statics.AllLowerCase, Interleaf(ref(callbackin), ref(interleafwith));
      }
      
      //makes certain that the first letter of the first word of every sentence (simple split on .?!) in the input.
      SentenceCase(var callbackIn): var
      {
         var iRes = Statics.FirstUppercase;
         foreach(var i in callbackIn)
         {
            if('.', '?', '!' contains i)
               Add(iRes, i, Statics.FirstUppercase);
            else
               Add(iRes, i);
         }
         return iRes;
      }
      
      //converts the input in characters and returns this list interleaft with spaces. This is similar to the AIML 'explode' tag.
      Explode(var toExplode): var
      {
         var iToExplode = StoCC(ToExplode);              //this returns a cluster, so we still need to delete this cluster after the operation. It's a bit slower, but works.   
         var iSpace = ' ';                            //interleaf expects a variable, so give this.
         var iRes = Interleaf(GetChildren(iToExplode), iSpace);
         delete(iToExplode);
         return iRes;
      }
      
      //calls the global 'doAfterStatement' code that is defined in the proejct's properties.
      CallDoAfterStatement()
      {
         PatternMatcher.CallDoAfterStatement();
      }

      //global operator overload for ==
      ==(var left, var right): bool                                     //compare 2 values
      {
         return ComparePathValues(left, right);
      }
      
      //defines how to process root path items, like in '$test.second', 'test' is the root path item. 
      {                                            
         get(var name): var
         {
            var iResult;
            name = GetFirstOut(pattern, name);          
            if (Count(name) > 0)                                                       //don't render error if it's 0, could be that it's simply hasn't been calculated.
            {
               fCurrentVar = Execute(name);
               if (Count(fCurrentVar) > 0)                                                                                  //if there was a result, and it came from a thesVar, make certain that we Filter the correct text value and not the object, cause this might map to a different synonym.  
               {
                  foreach (var iLoopVar in fCurrentVar)
                     Add(iResult, GetChildren(iLoopVar));
               }
            }
            return iResult;   
         }
         set(var name, var value)
         {
            var iVarCluster;
            var iVarCollector = GetFirstOut(pattern, name);
            if (Count(iVarCollector) > 0)
            {
               iVarCluster = Execute(iVarCollector);
               if (Count(iVarCluster) > 0)
               {
                  ClearChildren(iVarCluster);
                  AddChild(iVarCluster, value);
               }
               else
               {
                  iVarCluster = MakeCluster(iVarCollector, value);
                  Execute(ref(iVarCollector)) = iVarCluster;
                  AddChild(PatternMatcher.SplitResults, iVarCluster);
                  PatternMatcher.LoadAndConvertPatternResults.VarsToClear = Distinct(PatternMatcher.LoadAndConvertPatternResults.VarsToClear, iVarCollector);
               }
               Add(ref(PatternMatcher.ItemsToFreeze), PatternMatcher.splitresults, iVarCluster);   //we can't freeze the items directly but instead need to pass them on through the 'Items to Freeze' var cause the do-var-operation can be called from a 'Render', which is in a different thread. We would loose the data this way.    
            }
            else
            {
               iVarCollector = New(Statics.Variable);
               AddLink(pattern, iVarCollector, name);
               iVarCluster = MakeCluster(iVarCollector, value);
               Execute(ref(iVarCollector)) = iVarCluster;
               AddChild(PatternMatcher.splitresults, iVarCluster);
               add(ref(PatternMatcher.LoadAndConvertPatternResults.VarsToClear), iVarCollector);
               Add(ref(PatternMatcher.ItemsToFreeze), PatternMatcher.splitresults, iVarCluster, iVarCollector);   //we can't freeze the items directly but instead need to pass them on through the 'Items to Freeze' var cause the do-var-operation can be called from a 'Render', which is in a different thread. We would loose the data this way.    
            }
         }
         +=(var name, var value)                                                 //adds an item to the variable.
         {
            var iVarCluster;
            var iVarCollector = GetFirstOut(pattern, name);
            if (Count(iVarCollector) > 0)
            {
               iVarCluster = Execute(iVarCollector);
               if (Count(iVarCluster) == 0)
               {
                  iVarCluster = MakeCluster(iVarCollector, value);
                  Execute(ref(iVarCollector)) = iVarCluster;
                  AddChild(PatternMatcher.SplitResults, iVarCluster);
                  PatternMatcher.LoadAndConvertPatternResults.VarsToClear = Distinct(PatternMatcher.LoadAndConvertPatternResults.VarsToClear, iVarCollector);
               }
               else
                  AddChild(iVarCluster, value);
               Add(ref(PatternMatcher.ItemsToFreeze), PatternMatcher.splitresults, iVarCluster);   //we can't freeze the items directly but instead need to pass them on through the 'Items to Freeze' var cause the do-var-operation can be called from a 'Render', which is in a different thread. We would loose the data this way.    
            }
            else
            {
               iVarCollector = New(Statics.Variable);
               AddLink(pattern, iVarCollector, name);
               iVarCluster = MakeCluster(iVarCollector, value);
               Execute(ref(iVarCollector)) = iVarCluster;
               AddChild(PatternMatcher.splitresults, iVarCluster);
               add(ref(PatternMatcher.LoadAndConvertPatternResults.VarsToClear), iVarCollector);
               Add(ref(PatternMatcher.ItemsToFreeze), PatternMatcher.splitresults, iVarCluster, iVarCollector);   //we can't freeze the items directly but instead need to pass them on through the 'Items to Freeze' var cause the do-var-operation can be called from a 'Render', which is in a different thread. We would loose the data this way.    
            }
         }
         -=(var name, var value)                                        //removes an item from the variable.
         {
            var iVarCluster;
            var iVarCollector = GetFirstOut(pattern, name);
            if (Count(iVarCollector) > 0)
            {
               iVarCluster = Execute(iVarCollector);
               if (Count(iVarCluster) == 0)
               {
                  iVarCluster = MakeCluster(iVarCollector);
                  Execute(ref(iVarCollector)) = iVarCluster;
                  AddChild(PatternMatcher.SplitResults, iVarCluster);
                  PatternMatcher.LoadAndConvertPatternResults.VarsToClear = Distinct(PatternMatcher.LoadAndConvertPatternResults.VarsToClear, iVarCollector);
               }
               else
                  RemoveChild(iVarCluster, value);
               Add(ref(PatternMatcher.ItemsToFreeze), PatternMatcher.splitresults, iVarCluster);   //we can't freeze the items directly but instead need to pass them on through the 'Items to Freeze' var cause the do-var-operation can be called from a 'Render', which is in a different thread. We would loose the data this way.    
            }
            else
            {
               iVarCollector = New(Statics.Variable);
               AddLink(pattern, iVarCollector, name);
               iVarCluster = MakeCluster(iVarCollector);
               Execute(ref(iVarCollector)) = iVarCluster;
               AddChild(PatternMatcher.splitresults, iVarCluster);
               add(ref(PatternMatcher.LoadAndConvertPatternResults.VarsToClear), iVarCollector);
               Add(ref(PatternMatcher.ItemsToFreeze), PatternMatcher.splitresults, iVarCluster, iVarCollector);   //we can't freeze the items directly but instead need to pass them on through the 'Items to Freeze' var cause the do-var-operation can be called from a 'Render', which is in a different thread. We would loose the data this way.    
            }
         }     
         
         //when the var path starts with 'Time'
         Time
         {
            get(): var
            {
               return Statics.Time;
            }
            
            :TimeFunctions
            {
               //get the seconds section from a time value
               second(var callbackIn): int
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     return GetChildAt(callbackin, 5);
                  else
                     return GetChildAt(callbackin, 3);
               }

               //get the hours section from a time value
               hour(var callbackIn): int
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     return GetChildAt(callbackin, 3);
                  else
                     return GetChildAt(callbackin, 1);
               }
               
               //get the hours section from a time value expressed in the 12H system
               hour12(var callbackIn): int
               {
                  int iRes;
                  if (GetClusterMeaning(callbackin) == ref(time))
                     iRes = GetChildAt(callbackin, 3);
                  else
                     iRes = GetChildAt(callbackin, 1);
                  if(iRes > 12)
                     return iRes - 12;
                  else
                     return iRes;
               }
               
               //returns either AM or PM depending on the hour.
               AMPM(var callbackIn): var
               {
                  int iRes;
                  if (GetClusterMeaning(callbackin) == ref(time))
                     iRes = GetChildAt(callbackin, 3);
                  else
                     iRes = GetChildAt(callbackin, 1);
                  if(iRes > 12)
                     return 'PM';
                  else
                     return 'AM';
               }
               
               //get the minutes section from a time value
               minute(var callbackIn): int
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     return GetChildAt(callbackin, 4);
                  else
                     return GetChildAt(callbackin, 2);
               }
               
               //return the current year
               year(var callbackIn): int
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     return GetChildAt(callbackin, 0);
                  else
                     return;                                //no value to return.
               }
               //return the current day
               day(var callbackIn): int
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     return GetChildAt(callbackin, 2);
                  else
                     return GetChildAt(callbackin, 0);
               }
               //return the current month
               month(var callbackIn): int
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     return GetChildAt(callbackin, 1);
                  else
                     return;                                //no value to return.
               }
               //return the day of the week.
               dayofweek(var callbackIn): int
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     return GetChildAt(callbackin, 6);
                  else
                     return;                                      //no value to return.
               }
            
            }
         }
         
         topics
         {
            get(): var                          //gets all the topics assigned to the last statement.   
            {
               var iLog = GetFirstOut(OutputSin, PatternMatcher.CurrentConversation);
               var iLastInputStatement = GetLastChild(iLog);
               return GetOutgoing(iLastInputStatement, AttachedTopics);
            }
            set(var value)                   //sets the topic of the current input
            {
               var iLog = GetFirstOut(OutputSin, PatternMatcher.CurrentConversation);
               var iLastInputStatement = GetLastChild(iLog);
               RemoveLinksOut(iLastInputStatement, PatternMatcher.Rules);
               RemoveLinksOut(iLastInputStatement, AttachedTopics);
               AddLink(iLastInputStatement, value, AttachedTopics);
            }
            +=(var value)                       //adds a topic to the current input.   
            {
               var iLog = GetFirstOut(OutputSin, PatternMatcher.CurrentConversation);
               var iLastInputStatement = GetLastChild(iLog);
               if (LinkExists(iLastInputStatement, value, AttachedTopics) == false)
                  AddLink(iLastInputStatement, value, AttachedTopics);
            }
            -=(var value)                       //adds a topic from the current input.         
            {
               var iLog = GetFirstOut(OutputSin, PatternMatcher.CurrentConversation);
               var iLastInputStatement = GetLastChild(iLog);
               if (LinkExists(iLastInputStatement, value, AttachedTopics))
                  RemoveLink(iLastInputStatement, value, AttachedTopics);
            }
         }
         
         //retursn all the topics of the current conversation (the entire conversation log)
         AllTopics
         {
            get(): var
            {
               var iLog = GetFirstOut(OutputSin, PatternMatcher.CurrentConversation);
               var iRes, rule;
               foreach (var iLastInputStatement in GetChildren(iLog))
               {
                  add(iRes, GetOutgoing(iLastInputStatement, AttachedTopics));
                  iLastInputStatement = GetOutgoing(iLastInputStatement, PatternMatcher.Rules);
                  foreach (rule in iLastInputStatement)
                     add(iRes, GetFirstCluster(rule, Statics.Topic));
               }
               var iClusterMeaning;
               foreach (rule in GetChildren(GetFirstCluster(PatternMatcher.SplitResults, PatternMatcher.FinalResult)))  //we simply take all the clusters, will always be only 1.    
               {
                  iClusterMeaning = GetClusterMeaning(rule);
                  if (Count(iClusterMeaning) > 0)
                  {
                     rule = GetFirstCluster(iClusterMeaning, Statics.Rule);
                     add(iRes, GetFirstCluster(rule, Statics.Topic));
                  }
               }
               iRes = Distinct(iRes);
               return iRes;
            }
         }
         
         //returns all the rules found in the current input
         Rules
         {
            get(): var
            {
               var iClusterMeaning, iRes;
               foreach (var rule in GetChildren(GetFirstCluster(PatternMatcher.SplitResults, PatternMatcher.FinalResult)))//we simply take all the clusters, will always be only 1.    
               {
                  iClusterMeaning = GetClusterMeaning(rule);
                  if (Count(iClusterMeaning) > 0)
                  {
                     rule = GetFirstCluster(iClusterMeaning, Statics.Rule);
                     add(iRes, rule);
                  }
               }
               return iRes;
            }
         }
         
         
         //gets/set a limit to which topics are allowed in the next run. 
         NextTopics
         {
            get(): var                          //gets all the topics assigned to be expected for the next input
            {
               return GetChildren(PatternMatcher.nexttopicsbuffer);
            }
            set(var value)                   //sets the topic assigned to be expected for the next input
            {
               ClearChildren(PatternMatcher.nexttopicsbuffer);
               AddChild(PatternMatcher.nexttopicsbuffer, value);
            }
            +=(var value)                       //adds a topic to be expected for the next input
            {
               AddChild(PatternMatcher.nexttopicsbuffer, value);
            }
            -=(var value)                       //adds a topic from the list of expected topics for the next input
            {
               RemoveChild(PatternMatcher.nexttopicsbuffer, value);
            }
         }
         
         //returns the output that has been rendered so far.
         Output
         {
            get(): var
            {
               PatternMatcher.RenderPatternItems.PrevContentIsUsed = true;                                     //we need to let the output renderer know that the previous output has been consumed, so that it can render things correctly according to the settings (sometimes, if the output has been used, it is not included again in hte output)
               return PatternMatcher.RenderResultPattern.PrevContent;
            }
         }
         
         //index accessor and setter.
         [] VarIndex
         {
            get(var input, int index): var
            {
               return input[index];
            }
           
            (VarFunctions)
         }
         
         //all the functions that can be called in the var paths. 
         : varFunctions
         {
            (VarFunctions)                      //you can call multiple functions after each other
            (VarIndex)

            //when the value was collected with a thesaurus path, this function will convert the object back to the exact words as was found in the input.
            //this is used to make certain that the output renders the exact same word as the input, and not the first item in the object.
            ToText(var input): var
            {
               int iCounter;
               var iRes;
               var iIndexOfText = GetOutgoing(fCurrentVar, PatternMatcher.IndexOfText);
               if (Count(iIndexOfText) > 0) 
               {
                  while (Count(iIndexOfText) > iCounter)                                                             //we loop through all the indexes, of which there should be a similar amount as children, to get the exact word used by the user. This is only valid if we collected from a thes var, so we use the count of 'Index of text'.    
                  {
                     if (iIndexOfText[iCounter] > -1)
                        Add(iRes, GetChildAt(GetChildAt(fCurrentVar, iCounter), iIndexOfText[iCounter]));
                     else
                        Add(iRes, GetChildAt(fCurrentVar, iCounter));
                     iCounter++;
                  }   
               }
               return iRes;
            }
            
            //inverts I and You 
            InvertPerson(var toInvert): var
            {
               return Convert.InvertPerson(toInvert);
            }
            
            //switches I and he/she
            InvertPerson2(var toInvert): var
            {
               return Convert.InvertPerson2(toInvert);
            }
            

            //get the seconds section from a time value
            second(var callbackIn): int[]
            {
               var iRes;
               foreach(callbackIn in callbackIn)
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     Add(iRes, GetChildAt(callbackin, 5));
                  else
                     Add(iRes, GetChildAt(callbackin, 3));
               }
               return iRes;
            }
            

            //get the hours section from a time value
            hour(var callbackIn): int[]
            {
               var iRes;
               foreach(callbackIn in callbackIn)
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     Add(iRes, GetChildAt(callbackin, 3));
                  else
                     Add(iRes, GetChildAt(callbackin, 1));
               }
               return iRes;
            }
            
            //get the minutes section from a time value
            minute(var callbackIn): int[]
            {
               var iRes;
               foreach(callbackIn in callbackIn)
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     Add(iRes, GetChildAt(callbackin, 4));
                  else
                     Add(iRes, GetChildAt(callbackin, 2));
               }
               return iRes;
            }
            
            year(var callbackIn): int[]
            {  
               var iRes;
               foreach(callbackIn in callbackIn)
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     Add(iRes, GetChildAt(callbackin, 0));
               }
               return iRes;
            }
            
            day(var callbackIn): int[]
            {
               var iRes;
               foreach(callbackIn in callbackIn)
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     Add(iRes, GetChildAt(callbackin, 2));
                  else
                     Add(iRes, GetChildAt(callbackin, 0));
               }
               return iRes;
            }
            month(var callbackIn): int[]
            {
               var iRes;
               foreach(callbackIn in callbackIn)
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     Add(iRes, GetChildAt(callbackin, 1));
               }
               return iRes;
            }
            
            dayofweek(var callbackIn): int[]
            {
               var iRes;
               foreach(callbackIn in callbackIn)
               {
                  if (GetClusterMeaning(callbackin) == ref(time))
                     Add(iRes, GetChildAt(callbackin, 6));
               }
               return iRes;
            }
            
            /*
              used in a variable path to indicate that the count of the input set should be returned.
             */
            Count(var callbackIn): int
            {
               return Count(callbackin);
            }
            
            /*
              used in a variable path to indicate that a new value should be generated/calculated that completes the input set.
             */
            complete(var callbackIn): var
            {
               var exec = New(neuron);
               var callresult = New(neuroncluster);
               AddLink(exec, callresult, DoComplete);
               AddInfo(exec, callresult, DoComplete, callbackin);
               BlockedSolve(exec);
               var callbackout = GetChildren(callresult);
               Freeze(callresult, GetChildren(callresult));
               return callbackOut;
            }
            
            //performs an interleaf where each item to interleaf is the same
            //used to create things like 'a, b, c'
            Interleave(var value, var toInsert): var
            {
               return Interleaf(ref(value), ref(toInsert));
            }
            
            //performs an interleaf where the last item to interleaf is another item
            //used to create things like 'a, b, c and d'
            Interleave(var value, var toInsert, var toInsertAtEnd): var
            {
               return Interleaf(ref(value), ref(toInsert), ref(toInsertAtEnd));
            }
            
            
             //Checks if the input is an object, compound, textneuron or Statics.PosGroup and returns true or false. There can be no more items after this path item.
            IsAbstract(var callbackin): bool
            {
               return (Statics.Object, Statics.CompoundWord, Statics.PosGroup Contains GetClusterMeaning(callbackin)) || (TypeOf(callbackin) == textneuron);
            }
            
            //Checks if the input is a concrete item (asset) and returns true or false. There can be no more items after this path item.
            IsConcrete(var callbackin): bool
            {
               return GetClusterMeaning(callbackin) == Assets.Asset;
            }
            
            /*
              converts to input from an asset to a child of the argument.
               input: an asset
               argument: a thesaurus item, (like adj.possesive).
               Output: a child of the thesaurus item that maps to the argument (I, you, ...
                */
            AssetToThes(var input, var thesValue): var
            {
               return Convert.AssetToThes(input, thesValue);
            }
            
            //for legacy, see AssetToThes.
            ToPerson(var input, var thesValue): var
            {
               return Convert.AssetToThes(input, thesValue);
            }
            
            /*
                 Converts the input into an asset, taking into account for 'I', 'you', 'he/she', 'it', 'plural', 'singular', 'male', 'female'. If the input can't be mapped to 'I', you,... it is interpreted as the name of something and will try to find a focused object that has the specified name.
               I and you are first inverted, so I is interpreted as the user, while 'you' is interpreted as the bot.
               Input has to be objects, with at least 1 thesaurus parent to perform the mappings.
                */
            ObjectToAsset(var input): var
            {
               return Convert.ObjectToAsset(input, ());
            }
            
            /*
                 Converts the input into an asset, taking into account for 'I', 'you', 'he/she', 'it', 'plural', 'singular', 'male', 'female'. If the input can't be mapped to 'I', you,... it is interpreted as the name of something and will try to find a focused object that has the specified name.
               I and you are first inverted, so I is interpreted as the user, while 'you' is interpreted as the bot.
               Input has to be objects, with at least 1 thesaurus parent to perform the mappings.
                */
            ObjectToAsset(var input, var context): var
            {
               return Convert.ObjectToAsset(input, context);
            }
            
            //same as ObjectToAsset, for legacy.
            ResolvePerson(var input): var
            {
               return Convert.ObjectToAsset(input, ());
            }
            
            //same as ObjectToAsset, for legacy.
            ResolvePerson(var input, var context): var
            {
               return Convert.ObjectToAsset(input, context);
            }
            
            /*
              Checks if the current input is a list and returns true or false. There can be no more items after this path item.
             */
            Islist(var input):bool
            {
               return Statics.Argument, Statics.List Contains GetClusterMeaning(input);
            }
            /*
              Checks if the current asset-path result is an 'And' cluster and returns true or false. There can be no more items after this path item.
             */
            IsAnd(var input): bool
            {
               return Statics.AndAnd == GetClusterMeaning(input);
            }
            /*
              Checks if the current asset-path result is an 'or' cluster and returns true or false. There can be no more items after this path item.
             */
            IsOr(var input): bool
            {
               return Statics.OrOr == GetClusterMeaning(input);
            }
            
            /*
              Tries to conjugatte the verb to the form that corresponds with the argument. The argument should be 1 item, usually  '#bot.MextMem.who.val'. No attempt is made to try to convert objects to conjugation mappings, all objects are treated as 'it'.
             */
            ConjugateVerb(var input, var relativeTo):var
            {
               return Convert.ConjugateVerb(input, relativeTo);
            }
            
            /*
              Tries to conjugatte the verb to the inverted form that corresponds with the argument (so 'you' becomes 'I'). The argument should be 1 item, usually  '#bot.MextMem.who.val'. No attempt is made to try to convert objects to conjugation mappings, all objects are treated as 'it'.
             */
            ConjugateInvVerb(var input, var relativeTo): var
            {
               return Convert.ConjugateVerb.Inv(input, relativeTo);
            }
            
            //returns all the assets that directly link to the input as value. No effort is made to convert the value to object/text/posgroup, only a direct link is used.
            GetAssetsFromValue(var input): var
            {
               return Search.GetAssetsFromValue(input, ());
            }
            
            //returns all the assets that directly link to the input as value for the specified attribute value. No effort is made to convert the value to object/text/posgroup, only a direct link is used.
            GetAssetsFromValue(var input, var attribVal): var
            {
               return Search.GetAssetsFromValue(input, attribVal);
            }
            
            //returns all the assets that directly link to the input as value.   No effort is made to convert the value to object/text/posgroup, only a direct link is used.
            FindAssetsFromValue(var input): var
            {
               return Search.FindAssetsFromValue(input, ());
            }
            
            //returns all the assets that directly link to the input as value for the specified attribute value.  No effort is made to convert the value to object/text/posgroup, only a direct link is used.
            FindAssetsFromValue(var input, var attribVal): var
            {
               return Search.FindAssetsFromValue(input, attribVal);
            }
            
            //Returns the assets that have items with an attribute specified in the input.
            AttributeFor(var input): var
            {
               return Search.GetAttributeFor(input);
            }
            
            //Returns true if the input (which should be a cluster in some form) contains any of the specified arguments as child. The arguments can be objects or text, automatic conversion is done.
            ContainsChild(var list, var child): bool
            {
               return CalculateContainsChild(list, child);
            }
            
            // Takes in many possible values (asset clusters), and returns those who have an  outgoing-link with the data specified in the arguments.   
            Filter(var input, var outgoing): var
            {
               return waitFor Search.FilterAssets(input, outgoing);
            }
            
            //the attribute of the input should be calculated. This attribute can be used in an asset relationship. This is done by trying to find a thesaurus node that has a link to itself with the 'attribute' meaning.
            Attribute(var callbackIn): var
            {
               return waitfor Assets.CalculateAttribute(callbackIn, OutputSin, PatternMatcher.SplitResults);
            }
            //the attribute of the input should be calculated. This attribute can be used in an asset relationship. This is done by trying to find a thesaurus node that has a link to itself with the 'attribute' meaning.
            //The callback can supply argumetns, which will be used as 'context'. The closer a result matches one of the context values, the higher the weight of the result will be.
            Attribute(var callbackIn, var context): var
            {
               return waitfor Assets.CalculateAttribute.WithContext(callbackIn, OutputSin, PatternMatcher.SplitResults, context);
            }
            
            //Gets the immediate thesaurus parent from the input value. the 'isa' relationship is presumed.
            ThesParent(var input): var
            {
               if(count(input) > 0)
                  return GetThesParent(input);
               else
                  return;
            }
            
            //Gets the immediate thesaurus parent from the input value. If no meaning is defined, the 'isa' relationship is presumed.
            ThesParent(var input, var meaning): var
            {
               if(count(input) > 0)
                  return GetThesParent.ForMeaning(input, meaning);
               else
                  return;
            }
            
            //checks if the item in the argument is a thesaurus child (with the 'is a' relationship) of the path.
            IsaOf(var input, var toCheck): bool
            {
               return waitFor Search.IsaOf(input, toCheck);
            }
            
            //Tries to convert the input to a number. The input should be an object or something that can be mapped to an object. The first number found in the objects, is returned.
            ToNumber(var input): var
            {
               return Convert.ToNumber(input);
            }
            
              /* input: an object
              output: The instruction contained in the object. */
            GetInstruction(var callbackIn): var
            {
               return GetChildrenOfType(callbackin, Statics.Instruction);
            }
            
            //returns the last child of the &&, || or ; cluster and removes the item from the list.
            popchild(var callbackIn): var
            {
               var iRes = GetLastChild(callbackin);
               RemoveChildAt(callbackin, (ChildCount(callbackin) - 1));
               return iRes;
            }
            
            /*  input: a cluster containing a list of numbers and possibly instructions.
               output: the result of the value and instructions on the stack.
               calculation: get the last element on the stack, while this is a multiply-leveled instruction ( * / % ), get the next 2 items from the stack and calculate the result (which is returned). All items are removed from the list. */ 
            solvemultiplystack(var callbackIn): var
            {
               return Convert.solvemultiplystack(callbackIn);
            }
            
            /* input: a cluster containing a list of numbers and possibly instructions.
               output: the result of the value and instructions on the stack.
               calculation: get the last element on the stack, while this is an add-leveled iInstruction (+-), get the next 2 items from the stack and calculate the result (which is returned). All items are removed from the list. */ 
            solveaddstack(var callbackIn): var
            {
               return Convert.solveaddstack(callbackIn);
            }
            
            //makes certain that the first letter of the words passed in as input, are in upper case.
            ucase(var callbackin): var
            {
               var interleafwith = Statics.FirstUppercase;
               return Statics.FirstUppercase, Interleaf(ref(callbackin), ref(interleafwith));
            }
           //makes certain that al the letters of the words passed in as input, are in upper case.
            allucase(var callbackin): var
            {
               var interleafwith = Statics.AllUpperCase;
               return Statics.AllUpperCase, Interleaf(ref(callbackin), ref(interleafwith));
            }
            
           //makes certain that al the letters of the words passed in as input, are in lower case.
            AllLCase(var callbackin): var
            {
               var interleafwith = Statics.AllLowerCase;
               return Statics.AllLowerCase, Interleaf(ref(callbackin), ref(interleafwith));
            }
            
            //makes certain that the first letter of the first word of every sentence (simple split on .?!) in the input.
            SentenceCase(var callbackIn): var
            {
               var iRes = Statics.FirstUppercase;
               foreach(var i in callbackIn)
               {
                  if('.', '?', '!' contains i)
                     Add(iRes, i, Statics.FirstUppercase);
                  else
                     Add(iRes, i);
               }
               return iRes;
            } 
            
         }
      }
   }
  
   
   

   /*
     returns the last child of the &&, || or ; cluster.
    */
   NeuronCluster lastchild(Statics.Code): 1323
   {
      this()
      {
         callbackout = GetLastChild(callbackin);
         if (Union(Assets.GetassetPathResult) Contains Statics.CurrentMeaning)
         {
            AddSplitResult(callbackout);
            ExitSolve();
         }   //if this is for an asset path, add the value as a result, can't do anything else with it + need to exit for same reason.    
      }
   }
   /*
     returns the first child of the &&, || or ; cluster.
    */
   NeuronCluster firstchild(Statics.Code): 1324
   {
      this()
      {
         callbackout = GetFirstChild(callbackin);
         if (Union(Assets.GetassetPathResult) Contains Statics.CurrentMeaning)
         {
            AddSplitResult(callbackout);
            ExitSolve();
         }   //if this is for an asset path, add the value as a result, can't do anything else with it + need to exit for same reason.    
      }
   }
   /*
     returns the child of the &&, || or ; cluster at the specified index position (specified through argument)
    */
   NeuronCluster childat(Statics.Code): 1325
   {
      this()
      {
         BuildCallbackArgs();   //converts the cluster found in 'CallbackArgs' into a list of items, as defined by it's children, which can be static neurons or variables.    
         callbackout = GetChildAt(callbackin, callbackargs);
         if (Union(Assets.GetassetPathResult) Contains Statics.CurrentMeaning)
         {
            AddSplitResult(callbackout);
            ExitSolve();
         }   //if this is for an asset path, add the value as a result, can't do anything else with it + need to exit for same reason.    
      }
   }
   /*
     performs an arithmetic % to the input and all arguments.
   NeuronCluster _modulus(Statics.Code): 1318
   {
      this()
      {
         BuildCallbackArgs();   //converts the cluster found in 'CallbackArgs' into a list of items, as defined by it's children, which can be static neurons or variables.    
         callbackout = (callbackin % callbackargs);
         if (Union(Assets.GetassetPathResult) Contains Statics.CurrentMeaning)
         {
            AddSplitResult(callbackout);
            ExitSolve();
         }   //if this is for an asset path, add the value as a result, can't do anything else with it + need to exit for same reason.    
      }
   }
   */
   /*
     performs an arithmetic avg to the input and all arguments.
   NeuronCluster _avg(Statics.Code): 1317
   {
      this()
      {
         BuildCallbackArgs();   //converts the cluster found in 'CallbackArgs' into a list of items, as defined by it's children, which can be static neurons or variables.    
         callbackout = Avg(callbackin, callbackargs);
         if (Union(Assets.GetassetPathResult) Contains Statics.CurrentMeaning)
         {
            AddSplitResult(callbackout);
            ExitSolve();
         }   //if this is for an asset path, add the value as a result, can't do anything else with it + need to exit for same reason.    
      }
   }
   */
   /*
     performs an arithmetic max to the input and all arguments.
   NeuronCluster _max(Statics.Code): 1316
   {
      this()
      {
         BuildCallbackArgs();   //converts the cluster found in 'CallbackArgs' into a list of items, as defined by it's children, which can be static neurons or variables.    
         callbackout = Max(callbackin, callbackargs);
         if (Union(Assets.GetassetPathResult) Contains Statics.CurrentMeaning)
         {
            AddSplitResult(callbackout);
            ExitSolve();
         }   //if this is for an asset path, add the value as a result, can't do anything else with it + need to exit for same reason.    
      }
   }
   */
   /*
     performs an arithmetic min to the input and all arguments.
   NeuronCluster _min(Statics.Code): 1315
   {
      this()
      {
         BuildCallbackArgs();   //converts the cluster found in 'CallbackArgs' into a list of items, as defined by it's children, which can be static neurons or variables.    
         callbackout = Min(callbackin, callbackargs);
         if (Union(Assets.GetassetPathResult) Contains Statics.CurrentMeaning)
         {
            AddSplitResult(callbackout);
            ExitSolve();
         }   //if this is for an asset path, add the value as a result, can't do anything else with it + need to exit for same reason.    
      }
   }
   */
   /*
     performs an arithmetic stdev to the input and all arguments.
   NeuronCluster _stdev(Statics.Code): 1314
   {
      this()
      {
         BuildCallbackArgs();   //converts the cluster found in 'CallbackArgs' into a list of items, as defined by it's children, which can be static neurons or variables.    
         callbackout = StDev(callbackin, callbackargs);
         if (Union(Assets.GetassetPathResult) Contains Statics.CurrentMeaning)
         {
            AddSplitResult(callbackout);
            ExitSolve();
         }   //if this is for an asset path, add the value as a result, can't do anything else with it + need to exit for same reason.    
      }
   }
   */
  
   
   /*
     Sends the input value back to the engine as an input statement so that it is processed as any other regular input statement. Processing is done by pushing a new neuron on the stack so that it gets executed after everything else has been done. This means that that last statement will be processed first.
   Input: a list of words.
   Output: none.
    */
   NeuronCluster processinput(Statics.Code): 1331
   {
      this()
      {
         var iNewTo = MakeCluster(Statics.Empty, callbackin);
         var exec = New(neuron);
         AddLink(exec, iNewTo, PatternMatcher.Main);
         Push(exec);
      }
   }
   
   /*
     returns all the dateTime clusters that are shared amongst the input values (which should be integers.
    */
   NeuronCluster getcommondates(Statics.Code): 1329
   {
      this()
      {
         BuildCallbackArgs();   //converts the cluster found in 'CallbackArgs' into a list of items, as defined by it's children, which can be static neurons or variables.    
         callbackout = GetCommonParentsWithMeaning(ref(time), callbackin, callbackargs);
      }
   }
   /*
     returns all the dateTime clusters that are contained by the input (simpler then GetCommonDates).
    */
   NeuronCluster getdates(Statics.Code): 1330
   {
      this()
      {
         Clear(ref(callbackout));
         foreach (callbackin in callbackin)
            callbackout = Union(callbackout, GetClustersWithMeaning(callbackin, ref(time)));
      }
   }

   
   /*
     Retrieves the variable result of another rule that should also be present in the current input result.
    */
   NeuronCluster getresultfromrule(Statics.Code): 1268
   {
      var Result, GetFromRule;
      this()
      {
         varCount++;
         var iVarCollector = GetChildAt(GetVarResult.ToProcess, varcount);
         var iAllResults = GetFirstCluster(PatternMatcher.SplitResults, PatternMatcher.FinalResult);   //we simply take all the clusters, will always be only 1.    
         GetFromRule = GetChildrenFiltered(iAllResults, ref(filtervar), ref((GetClusterMeaning(filtervar) == iVarCollector)));
         Result = New(neuroncluster);
         CallSave(getresultfromrulesave, GetFromRule, GetVarResult.ToProcess, Result, varcount);
         callbackout = GetChildren(Result);
         Delete(Result);
         Clear(ref(result), ref(GetFromRule));
         varCount++;
      }
   }
   /*
     this is the internal function that retrieves the result of a specific result cluster. This is done with a save call, hence the sub cluster. We ned a save call cause we need to extract the variable results from the result cluster, which could clash with the current results, so we do a savecall.
    */
   NeuronCluster getresultfromrulesave
   {
      this()
      {
         PatternMatcher.SplitResults = getresultfromrule.GetFromRule;
         PatternMatcher.LoadAndConvertPatternResults();   //Loads all the colected data into the variables.    When the data was collected by the parser, the iClusterMeaning of each data blob is the variable path that collected it, cause it didn't yet know  the pattern for which it was matching, so also not yet the variable.    During assignments though, there is no path to use as meaning, so the varaible is used as iClusterMeaning.    
         varCount++;
         var iVarCollector = GetChildAt(GetVarResult.ToProcess, varcount);
         if ((TypeOf(iVarCollector) != Statics.Variable) && (iVarCollector != ref(time)))
            iVarCollector = GetFirstOut(pattern, iVarCollector);   //    
         AddChild(getresultfromrule.Result, Execute(iVarCollector));
      }
   }
   
   /*
     Tries to dynamically find the rule with the specified name. Input should be 1 (or more) topics. The argument should be the name of the rule to find.
   Only 1 argument allowed.
    */
   NeuronCluster getrule(Statics.Code): 1270
   {
      this()
      {
         Clear(ref(callbackout));
         BuildCallbackArgs();   //converts the cluster found in 'CallbackArgs' into a list of items, as defined by it's children, which can be static neurons or variables.    
         callbackargs = Substract(ref(callbackargs), Statics.FirstUpperCase, Statics.AllUpperCase, Filter(ref(filtervar), ref((GetClusterMeaning(filtervar) == Statics.UpperCaseMap)), callbackargs));
         if (Count(callbackargs) > 1)
            callbackargs = GetFirst(GetCommonParentsFiltered(ref(filtervar), ref(((GetClusterMeaning(filtervar) == Statics.CompoundWord) && (GetChildren(filtervar) == callbackargs))), callbackargs));
         if (Count(callbackargs) > 0)
         {
            foreach (callbackin in callbackin)
               callbackout = Union(callbackout, GetChildrenFiltered(callbackin, ref(filtervar), ref((GetFirstOut(filtervar, Statics.NameOfMember) == callbackargs))));
         }
      }
   }
     
   
   /*
     resolves a parsed variable. This is a cluster that defines a path. Ususally , it starts with the name of the variable, but some 'hardStatics.Coded variables' like time or repeatCount are stored directly as the var itself.
   When the var is 'time' (or another cluster), it can be followed by an integer, indicating which part of the time is desired: year, month, day, hour,...
    */
   ExpressionsBlock GetVarResult
   {
      var ToProcess;                            //so that everybody can reach this value while trying to process the path
      statements(var varPath): var
      {
         var varResult;
         ToProcess = varPath;                      //needed for getresultfromrule
         ResolveOperands(GetOutgoing(varpath, Statics.operand));
         var iVarCollector = GetFirstChild(varpath);
         varcount = New(IntNeuron);
         if (GetClusterMeaning(iVarCollector) != Statics.Code)
         {
            if ((TypeOf(iVarCollector) != Statics.variable) && (iVarCollector != ref(time)))
               iVarCollector = GetFirstOut(pattern, iVarCollector);   //    
            if (Count(iVarCollector) > 0)
            {
               varresult = Execute(iVarCollector);
               if (Count(varresult) > 0)
               {
                  int iCounter;
                  if (iVarCollector != ref(time))
                  {
                     var iTempCollector;
                     var iIndexOfText = GetOutgoing(varresult, PatternMatcher.IndexOfText);
                     if ((LinkExists(varpath, varpath, Statics.ParsedThesVariable) == false) && (Count(iIndexOfText) > 0))
                     {
                        while (Count(iIndexOfText) > iCounter)      //we loop through all the indexes, of which there should be a similar amount as children, to get the exact word used by the user. This is only valid if we collected from a thes var, so we use the count of 'Index of text'.    
                        {
                           if (iIndexOfText[iCounter] > -1)
                              iTempCollector = Union(iTempCollector, GetChildAt(GetChildAt(varresult, iCounter), iIndexOfText[iCounter]));
                           else
                              iTempCollector = Union(iTempCollector, GetChildAt(varresult, iCounter));
                           iCounter++;
                        }   
                     }
                     else
                     {
                        foreach (var iLoopVar in varresult)
                           iTempCollector = Union(iTempCollector, GetChildren(iLoopVar));
                     }   //If the varpath links to itself with meaning 'ParsedThesVar', the user specified a thespath (that can be interpreted as a regular var path), so don't try to convert an object to a textneuron (which would result in the exact word that the user used), but instead keep the object.    
                     varresult = iTempCollector;
                  }
               }
            }
            else
               Error("Unknown variable: ", GetFirstChild(varpath));   //this is usually triggered when there was an invalid name for the variable.    
            Execute(ref(varcount)) = 1;
            if (ChildCount(varpath) > varcount)
               iVarCollector = GetChildAt(varpath, varcount);
            else
               Clear(ref(iVarCollector));
         }
         if (Count(iVarCollector) > 0)
         {
            while (Count(iVarCollector) > 0)
            {
               switch (GetClusterMeaning(iVarCollector))
               {
                  case Statics.Code:
                  {
                     callbackin = varresult;
                     Call(iVarCollector);
                     varresult = callbackout;
                     Clear(ref(callbackargs));
                  }
                  case Statics.arguments:
                  {
                     callbackargs = Union(callbackargs, iVarCollector);   //we can have mulitple arguments after each other.    
                     varCount++;
                     if (ChildCount(varpath) > varcount)
                        iVarCollector = GetChildAt(varpath, varcount);
                     else
                        Clear(ref(iVarCollector));
                     Continue();
                  }
                  case Statics.Index:
                  {
                     iVarCollector = GetFirstChild(iVarCollector);
                     if (TypeOf(iVarCollector) == Statics.resultstatement)
                        iVarCollector = Execute(iVarCollector);
                     else if(TypeOf(iVarCollector) != IntNeuron)
                     {
                        Error("Unknown index expression in variable path");
                        ExitSolve();
                     }
                     varresult = GetAt(iVarCollector, varresult);
                  }
                  case Statics.outlink: varresult = GetFirstOut(varresult, SolveSubPath(GetFirstChild(GetFirstChild(iVarCollector))));
                  default:
                  {
                     Error("Unknown type in variable path: ", iVarCollector);
                     ExitSolve();
                  }
               }
               
               if (Count(varresult) == 0)
                  Break();
               varCount++;
               if (ChildCount(varpath) > varcount)
                  iVarCollector = GetChildAt(varpath, varcount);
               else
                  Clear(ref(iVarCollector));
            }
         }
         Clear(ref(ToProcess));
         return varResult;
      }
   }
   


}
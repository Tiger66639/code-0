// --------------------------------------------------------------------------------------------------------------------
// <copyright file="Thesaurus.cs" company="">
//   
// </copyright>
// <summary>
//   Maintains the thesaurus view on the loaded network as generated by wordnet.
// </summary>
// --------------------------------------------------------------------------------------------------------------------
namespace JaStDev.HAB.Designer
{
    using System.Linq;

    /// <summary>
    ///     Maintains the thesaurus view on the loaded network as generated by wordnet.
    /// </summary>
    public class Thesaurus : Data.ObservableObject, 
                             IThesaurusData, 
                             System.Windows.IWeakEventListener, 
                             System.Xml.Serialization.IXmlSerializable, 
                             WPF.Controls.ITreeViewRoot, 
                             Data.IOnCascadedChanged
    {
        #region ctor/~

        /// <summary>
        ///     Initializes a new instance of the <see cref="Thesaurus" /> class.
        /// </summary>
        public Thesaurus()
        {
            fEventMonitor = new ThesaurusEventMonitor(this);
            NewRootEventManager.AddListener(WordNetSin.Default, this);
            RelationshipTypeCreatedEventManager.AddListener(WordNetSin.Default, this);
            foreach (var i in BrainData.Current.GrammarTypes)
            {
                // and we add all the default pos filters automatically. This includes an empty item.
                fPosFilters.Add(new ThesaurusRelItem(i));
            }
        }

        #endregion

        #region EventMonitoring

        /// <summary>Removes the specified id from the data dict. This is used by the monitoring object to do an async call.
        ///     Warning: can be called from another thread.</summary>
        /// <param name="id">The id.</param>
        internal void RemoveFromData(ulong id)
        {
            if (SelectedItem != null && SelectedItem.ID == id)
            {
                SelectedItem = null;
                System.Windows.Application.Current.Dispatcher.BeginInvoke(
                    System.Windows.Threading.DispatcherPriority.Normal, 
                    new System.Action(Items.Clear));

                    // do a clear async. Collectionchanges need to be done from the ui thread.
            }

            fLock.EnterWriteLock();
            try
            {
                LargeIDCollection iCol;
                if (Data.TryGetValue(id, out iCol))
                {
                    if (WindowMain.Current.Dispatcher.Thread == System.Threading.Thread.CurrentThread)
                    {
                        // we don't add undo data when it comes from running the network, this would generate to much undo data.
                        var iUndo = new ThesRelItemUndoData(BrainAction.Removed, id, iCol);
                        WindowMain.UndoStore.AddCustomUndoItem(iUndo);
                    }

                    Data.Remove(id); // this will remove an entire root if the id was for a relationship.
                }
            }
            finally
            {
                fLock.ExitWriteLock();
            }
        }

        #endregion

        /// <summary>Loads the data dictionary from the specified path. This is done seperatly, not in readxml, since we don't know
        ///     the project path yet when the xml is read. Thread unsafe</summary>
        /// <remarks>The relationships list is used to determin which items need to be loade, so make certain that they are already
        ///     loaded.
        /// <para>
        ///         Doesn't need to be thread save cause when the object is being loaded, it is not yet connected to the rest of
        ///         the
        ///         system, so others can't make any changes.</para>
        /// </remarks>
        /// <param name="path">The path.</param>
        internal void LoadData(string path)
        {
            LoadData(path, fData, THESDATAFILEPREFIX);
            ResetItems();

                // when the data is loaded, we always need to make certain that the prev is emptied. We do this after the load, since it could trigger an immediate reload when called (through OnPropertyChanged).
        }

        /// <summary>The load data.</summary>
        /// <param name="path">The path.</param>
        /// <param name="data">The data.</param>
        /// <param name="prefix">The prefix.</param>
        private void LoadData(string path, Data.SerializableDictionary<ulong, LargeIDCollection> data, string prefix)
        {
            foreach (var i in Relationships)
            {
                try
                {
                    var iList = new LargeIDCollection();
                    data.Add(i.Item.ID, iList);
                    var iPath = System.IO.Path.Combine(path, prefix + i.Item.ID + THESDATAFILEEXT);
                    iList.ReadData(iPath);
                }
                catch (System.Exception e)
                {
                    LogService.Log.LogError("Theaurus.LoadData", "Failed to load data file with error: " + e);
                }
            }
        }

        /// <summary>Saves the data dictionary to the designer path. thread unsafe.</summary>
        /// <param name="path">The path.</param>
        internal void SaveData(string path)
        {
            try
            {
                foreach (var i in fData)
                {
                    var iPath = System.IO.Path.Combine(path, THESDATAFILEPREFIX + i.Key + THESDATAFILEEXT);
                    i.Value.SaveData(iPath);
                }
            }
            catch (System.Exception e)
            {
                LogService.Log.LogError(
                    "Thesaurus.SaveData", 
                    string.Format("Failed to save the thesaurus data with error {0}", e));
            }
        }

        #region fields

        /// <summary>
        ///     the string that is in front of all the data files of the thesaurus.
        /// </summary>
        private const string THESDATAFILEPREFIX = "Thesaurus_Rel_";

        /// <summary>
        ///     The extention for thesaurus data files.
        /// </summary>
        private const string THESDATAFILEEXT = ".dat";

        /// <summary>The f event monitor.</summary>
        private ThesaurusEventMonitor fEventMonitor;

        /// <summary>The f relationships.</summary>
        private ThesaurusRelItemCollection fRelationships = new ThesaurusRelItemCollection();

        /// <summary>The f no recursive relationships.</summary>
        private ThesaurusRelItemCollection fNoRecursiveRelationships = new ThesaurusRelItemCollection();

        /// <summary>The f pos filters.</summary>
        private readonly ThesaurusRelItemCollection fPosFilters = new ThesaurusRelItemCollection();

        /// <summary>The f conjugation meanings.</summary>
        private ThesaurusRelItemCollection fConjugationMeanings = new ThesaurusRelItemCollection();

        /// <summary>The f sub items.</summary>
        private SubRelationshipsCollection fSubItems;

        /// <summary>The f pos related.</summary>
        private ThesaurusLinkedItems fPOSRelated;

        /// <summary>The f object related.</summary>
        private ThesObjectLinkedItems fObjectRelated;

        /// <summary>The f conjugations.</summary>
        private ThesaurusLinkedItems fConjugations;

        /// <summary>The f selected item.</summary>
        private ThesaurusItem fSelectedItem;

        /// <summary>The f data.</summary>
        private Data.SerializableDictionary<ulong, LargeIDCollection> fData =
            new Data.SerializableDictionary<ulong, LargeIDCollection>();

        /// <summary>The f selected sub relationship.</summary>
        private ThesaurusSubItemCollection fSelectedSubRelationship;

        /// <summary>The f lock.</summary>
        private readonly System.Threading.ReaderWriterLockSlim fLock = new System.Threading.ReaderWriterLockSlim();

        /// <summary>The f selected relationship index.</summary>
        private int fSelectedRelationshipIndex;

        /// <summary>The f selected pos filter index.</summary>
        private int fSelectedPosFilterIndex;

        /// <summary>The f is sub items loaded.</summary>
        private bool fIsSubItemsLoaded;

        /// <summary>The f building list.</summary>
        private bool fBuildingList; // used to keep track wether we are already building the list async or not.

        /// <summary>The f thes hor scroll pos.</summary>
        private double fThesHorScrollPos;

        /// <summary>The f thes ver scroll pos.</summary>
        private double fThesVerScrollPos;

        /// <summary>The f tree row height.</summary>
        private System.Windows.GridLength fTreeRowHeight = new System.Windows.GridLength(
            1.0, 
            System.Windows.GridUnitType.Star);

        /// <summary>The f sub items row height.</summary>
        private System.Windows.GridLength fSubItemsRowHeight = new System.Windows.GridLength(
            0.4, 
            System.Windows.GridUnitType.Star);

                                          // we immidiatly init to the size that we want when visible, the prop will take care of the actual value  (o or this).
        #endregion

        #region Events  

        // (ITreeViewRoot: NotifyCascadedPropertyChanged Members + ICascadedNotifyCollectionChanged Members)

        /// <summary>
        ///     Occurs when a property was changed in one of the thesaurus items. This is used for the tree display.
        /// </summary>
        public event Data.CascadedPropertyChangedEventHandler CascadedPropertyChanged;

        /// <summary>
        ///     Occurs when a collection was changed in one of the child items or the root list. This is used for the tree display.
        /// </summary>
        public event Data.NotifyCascadedCollectionChangedEventHandler CascadedCollectionChanged;

        /// <summary>
        ///     Occurs when the list of items has been reloaded or cleared.
        /// </summary>
        public event System.EventHandler ItemsChanged;

        #endregion

        #region Prop

        #region Data

        /// <summary>
        ///     Gets/sets the dictionary containing all the root items for each relationship.
        /// </summary>
        /// <remarks>
        ///     This still has a setter for old data formats, should not really be required anymore.
        /// </remarks>
        public Data.SerializableDictionary<ulong, LargeIDCollection> Data
        {
            get
            {
                return fData;
            }

            set
            {
                if (value != fData)
                {
                    fData = null;

                        // important to set fData to null before we clear the relationships, cause otherwise, we would clear out all the data, which is overkill
                    SelectedRelationshipIndex = -1;

                        // we reset the selected relationship index cause we remove all the items, if we don't do this, the list of displayed items isn't refreshed when the new selected index is assigned, which is the same value as the previous one.
                    Relationships.Clear();
                    fData = value;
                    foreach (var i in value)
                    {
                        Relationships.Add(new ThesaurusRelItem(Brain.Current[i.Key]));
                    }

                    ResetItems(); // also need to let the ui know something changed.
                }
            }
        }

        #endregion

        #region Searcher

        /// <summary>
        ///     Gets the search function associated with this object.
        /// </summary>
        internal ThesSearcher Searcher { get; set; }

        #endregion

        #region DataToSearch

        /// <summary>
        ///     Gets/sets the type of data that should be search.
        ///     this prop maps to the app's settings. We provide the prop here so that
        ///     we get PropertyChanged events for UI.
        /// </summary>
        public DataToSearch DataToSearch
        {
            get
            {
                return Properties.Settings.Default.ThesSearchMapCriterium;
            }

            set
            {
                Properties.Settings.Default.ThesSearchMapCriterium = value;
                OnPropertyChanged("DataToSearch");
            }
        }

        #endregion

        #region Relationships

        /// <summary>
        ///     Gets the list of known recursive relationships in the network.
        /// </summary>
        /// <remarks>
        ///     Use this to provide a dropdown list of all possible recursive relationships.
        /// </remarks>
        [System.Xml.Serialization.XmlElement("Relationships")]
        public ThesaurusRelItemCollection Relationships
        {
            get
            {
                return fRelationships;
            }
        }

        #endregion

        #region SelectedRelationshipIndex

        /// <summary>
        ///     Gets/sets the index of the currently selected relationship. When changed, all
        ///     <see cref="Thesaurus.Items" /> are refeshed.
        /// </summary>
        public int SelectedRelationshipIndex
        {
            get
            {
                return fSelectedRelationshipIndex;
            }

            set
            {
                if (fBuildingList)
                {
                    System.Windows.MessageBox.Show(
                        "Can't change relationship while loading the data for the previous", 
                        "Thesaurus", 
                        System.Windows.MessageBoxButton.OK, 
                        System.Windows.MessageBoxImage.Error);
                }
                else if (value != fSelectedRelationshipIndex)
                {
                    fSelectedRelationshipIndex = value;
                    OnPropertyChanged("SelectedRelationship");
                    OnPropertyChanged("SelectedRelationshipIndex");
                    ResetItems();
                }
            }
        }

        #endregion

        #region SelectedRelationship

        /// <summary>
        ///     Gets the neuron that represents the curently selected relationship .
        /// </summary>
        /// <value>The selected relationship.</value>
        [System.Xml.Serialization.XmlIgnore]
        public Neuron SelectedRelationship
        {
            get
            {
                if (fSelectedRelationshipIndex > -1 && fSelectedRelationshipIndex < Relationships.Count)
                {
                    return Relationships[fSelectedRelationshipIndex].Item;
                }

                return null;
            }
        }

        #endregion

        #region NoRecursiveRelationships

        /// <summary>
        ///     Gets the list of relationships that aren't recursive and therefor have no roots.
        /// </summary>
        /// <remarks>
        ///     Settable for xmlStreaming.
        /// </remarks>
        [System.Xml.Serialization.XmlElement("NoRecursiveRelationships")]
        public ThesaurusRelItemCollection NoRecursiveRelationships
        {
            get
            {
                return fNoRecursiveRelationships;
            }

            set
            {
                if (value != fNoRecursiveRelationships)
                {
                    fNoRecursiveRelationships = value;
                    OnPropertyChanged("NoRecursiveRelationships");
                }
            }
        }

        #endregion

        #region PosFilters

        /// <summary>
        ///     Gets the part of speech groups that are available in the thesaurus.
        /// </summary>
        public ThesaurusRelItemCollection PosFilters
        {
            get
            {
                return fPosFilters;
            }
        }

        #endregion

        #region SelectedPOSFilterIndex

        /// <summary>
        ///     Gets/sets the index of the currently selected relationship. When changed, all
        ///     <see cref="Thesaurus.Items" /> are refeshed.
        /// </summary>
        public int SelectedPosFilterIndex
        {
            get
            {
                return fSelectedPosFilterIndex;
            }

            set
            {
                if (fBuildingList)
                {
                    System.Windows.MessageBox.Show(
                        "Can't change relationship while loading the data for the previous", 
                        "Thesaurus", 
                        System.Windows.MessageBoxButton.OK, 
                        System.Windows.MessageBoxImage.Error);
                }
                else if (value != fSelectedPosFilterIndex)
                {
                    fSelectedPosFilterIndex = value;
                    OnPropertyChanged("SelectedPosFilter");
                    OnPropertyChanged("SelectedPosFilterIndex");
                    ResetItems();
                }
            }
        }

        /// <summary>
        ///     Resets the items list to null and lets any observers load a new one if needed.
        /// </summary>
        private void ResetItems()
        {
            Searcher = null;

                // when the list of items gets reset, we must make certain that the searcher is also removed.
            SelectedItem = null;
            if (InternalItems != null)
            {
                InternalItems.Clear(); // we clear so that all the references in the event monitor are also removed.
                InternalItems = null;
            }

            OnItemsChanged();
        }

        /// <summary>
        ///     Called when the list of Items has changed.
        /// </summary>
        private void OnItemsChanged()
        {
            OnPropertyChanged("Items");
            OnPropertyChanged("TreeItems");
            OnCascadedPropertyChanged(
                new Data.CascadedPropertyChangedEventArgs(
                    this, 
                    new System.ComponentModel.PropertyChangedEventArgs("TreeItems"))); // this is required for the UI
            if (ItemsChanged != null)
            {
                ItemsChanged(this, System.EventArgs.Empty);
            }
        }

        #endregion

        #region SelectedPOSFilter

        /// <summary>
        ///     Gets the neuron that is selected as POS filter.
        /// </summary>
        /// <value>The selected POS filter.</value>
        [System.Xml.Serialization.XmlIgnore]
        public Neuron SelectedPOSFilter
        {
            get
            {
                if (fSelectedPosFilterIndex > -1 && fSelectedPosFilterIndex < PosFilters.Count)
                {
                    return PosFilters[fSelectedPosFilterIndex].Item;
                }

                return null;
            }
        }

        #endregion

        #region ConjugationMeanings

        /// <summary>
        ///     Gets the link meanings used to indicate a verb conjugation, which are available in the thesaurus.
        ///     Used by the <see cref="Thesaurus.Conjugations" /> of the currently selected thesaurus item. Can be
        ///     edited by a sub form.
        /// </summary>
        public ThesaurusRelItemCollection ConjugationMeanings
        {
            get
            {
                return fConjugationMeanings;
            }

            set
            {
                if (value != fConjugationMeanings)
                {
                    fConjugationMeanings = value;
                    OnPropertyChanged("PosFilters");
                }
            }
        }

        #endregion

        /// <summary>
        ///     Gets/sets if we are currently building the items list or not. This is made available so taht
        ///     the thesaurus import can block the thesaurus from continuasly updating the view while loading the data. This is
        ///     faster.
        /// </summary>
        internal bool IsBuildingList
        {
            get
            {
                return fBuildingList;
            }

            set
            {
                fBuildingList = value;
                if (value == false)
                {
                    // when releasing the build, make certain that the view is updated.
                    OnPropertyChanged("TreeItems");
                    OnCascadedPropertyChanged(
                        new Data.CascadedPropertyChangedEventArgs(
                            this, 
                            new System.ComponentModel.PropertyChangedEventArgs("TreeItems")));

                        // this is required for the UI
                }
            }
        }

        #region Items

        /// <summary>
        ///     Gets the list of items. When the list isn't build yet, this is done async.
        ///     If you need immediate access to the list of items (and gets build during the call if needed),
        ///     use <see cref="Thesaurus.ItemsDirect" />
        /// </summary>
        [System.Xml.Serialization.XmlIgnore]
        public System.Collections.Generic.IList<ThesaurusItem> Items
        {
            get
            {
                if (InternalItems == null && BrainData.Current.DesignerData != null)
                {
                    // if designerData is null, we are still loading the project.
                    if (fBuildingList == false)
                    {
                        System.Action iBuildList = BuildListAsync;
                        iBuildList.BeginInvoke(null, null);
                    }
                }

                return InternalItems;
            }
        }

        /// <summary>
        ///     Builds the list async.
        /// </summary>
        private void BuildListAsync()
        {
            fBuildingList = true;
            try
            {
                var iItems = new ThesaursItemCollection(this);
                if (BrainData.Current.DesignerData != null)
                {
                    var iSelected = SelectedRelationship;
                    if (iSelected != null)
                    {
                        BuildItems(iSelected, SelectedPOSFilter, iItems);
                    }
                }

                InternalItems = iItems;
            }
            finally
            {
                fBuildingList = false;
            }

            OnItemsChanged();
        }

        #endregion

        #region ITreeViewRoot Members

        /// <summary>
        ///     Gets a list to all the children of the tree root.
        /// </summary>
        /// <value>The tree items.</value>
        /// <remarks>
        ///     Used for the interface to display the items in a fast treeview.
        /// </remarks>
        public System.Collections.IList TreeItems
        {
            get
            {
                return (System.Collections.IList)Items;
            }
        }

        #endregion

        #region InternalItems

        /// <summary>
        ///     Gets the list of items that can be used by the event monitor of the thesaurus item list.
        /// </summary>
        [System.Xml.Serialization.XmlIgnore]
        internal ThesaursItemCollection InternalItems { get; private set; }

        #endregion

        #region SelectedItem

        /// <summary>
        ///     Gets the currently selected thesaurusItem.  This prop is controlled by the thesaurus items themselfs.
        /// </summary>
        /// <remarks>
        ///     When changed, the <see cref="Thesaurus.SynonymsList" /> is also updated automatically.
        /// </remarks>
        [System.Xml.Serialization.XmlIgnore]
        public ThesaurusItem SelectedItem
        {
            get
            {
                return fSelectedItem;
            }

            internal set
            {
                if (value != fSelectedItem)
                {
                    SelectedSubRelationship = null;

                        // when the selected item is changed, the selected sub items collection is no longer valid.
                    fSelectedItem = value;
                    OnPropertyChanged("SelectedItem");
                    SubItems = null;
                    POSRelated = null;
                    Conjugations = null;
                    ObjectRelated = null;
                }
            }
        }

        #endregion

        #region SelectedSubRelationship

        /// <summary>
        ///     Gets/sets the currently selected sub relationship.
        /// </summary>
        [System.Xml.Serialization.XmlIgnore]
        public ThesaurusSubItemCollection SelectedSubRelationship
        {
            get
            {
                return fSelectedSubRelationship;
            }

            set
            {
                if (value != fSelectedSubRelationship)
                {
                    if (fSelectedSubRelationship != null)
                    {
                        fSelectedSubRelationship.IsSelected = false;
                    }

                    fSelectedSubRelationship = value;
                    if (fSelectedSubRelationship != null)
                    {
                        fSelectedSubRelationship.IsSelected = true;
                    }

                    OnPropertyChanged("SelectedSubRelationship");
                }
            }
        }

        #endregion

        #region SubItems

        /// <summary>
        ///     Gets the list of sub relationships for the currently selected thesaurus item.
        /// </summary>
        /// <remarks>
        ///     The link to the wrapped cluster is monitored by the thesaurus item since this already monitors all of it's links
        ///     anyway.
        /// </remarks>
        [System.Xml.Serialization.XmlIgnore]
        public SubRelationshipsCollection SubItems
        {
            get
            {
                if (fSubItems == null && fSelectedItem != null)
                {
                    fSubItems = new SubRelationshipsCollection(fSelectedItem.Item);
                    fSubItems.IsLoaded = IsSubItemsLoaded;
                }

                return fSubItems;
            }

            internal set
            {
                if (value != fSubItems)
                {
                    if (fSubItems != null)
                    {
                        // we make certain that the collection is cleared cause this will unregister all the neurons with the eventmanager that the collection is monitorring.
                        fSubItems.IsLoaded = false;
                    }

                    fSubItems = value;
                    if (fSubItems != null)
                    {
                        fSubItems.IsLoaded = IsSubItemsLoaded;
                    }
                }

                OnPropertyChanged("SubItems");

                    // always ask to update, let the other side deside: when we assign a 'null', we want it to be reloaded if needed, but only if needed, so assigning a null when it was already null needs to trigger an update.
            }
        }

        #endregion

        #region POSRelated

        /// <summary>
        ///     Gets the list of links (meaning and to)  for the currently selected thesaurus item, where the meaning is in the set
        ///     of pos values.
        /// </summary>
        [System.Xml.Serialization.XmlIgnore]
        public ThesaurusLinkedItems POSRelated
        {
            get
            {
                if (fPOSRelated == null && fSelectedItem != null)
                {
                    fPOSRelated = new ThesaurusLinkedItems(fSelectedItem.Item, PosFilters);
                    fPOSRelated.IsLoaded = IsSubItemsLoaded;
                }

                return fPOSRelated;
            }

            internal set
            {
                if (value != fPOSRelated)
                {
                    if (value == null && fPOSRelated != null)
                    {
                        // if we set the items to null, but there were still items assigned, we make certain that the collection is cleared cause this will unregister all the neurons with the eventmanager that the collection is monitorring.
                        fPOSRelated.Clear();
                    }

                    fPOSRelated = value;
                    if (fPOSRelated != null)
                    {
                        fPOSRelated.IsLoaded = IsSubItemsLoaded;
                    }
                }

                OnPropertyChanged("POSRelated"); // it could be null, so always let it update when setter called.
            }
        }

        #endregion

        #region POSRelated

        /// <summary>
        ///     Gets the list of links (meaning and to)  for the currently selected thesaurus item, where the meaning is in the set
        ///     of pos values.
        /// </summary>
        [System.Xml.Serialization.XmlIgnore]
        public ThesObjectLinkedItems ObjectRelated
        {
            get
            {
                if (fObjectRelated == null && fSelectedItem != null)
                {
                    fObjectRelated = new ThesObjectLinkedItems(fSelectedItem.Item);
                    fObjectRelated.IsLoaded = IsSubItemsLoaded;
                }

                return fObjectRelated;
            }

            internal set
            {
                if (value != fObjectRelated)
                {
                    if (value == null && fObjectRelated != null)
                    {
                        // if we set the items to null, but there were still items assigned, we make certain that the collection is cleared cause this will unregister all the neurons with the eventmanager that the collection is monitorring.
                        fObjectRelated.Clear();
                    }

                    fObjectRelated = value;
                    if (fObjectRelated != null)
                    {
                        fObjectRelated.IsLoaded = IsSubItemsLoaded;
                    }
                }

                OnPropertyChanged("ObjectRelated"); // it could be null, so always let it update when setter called.
            }
        }

        #endregion

        #region Conjugations

        /// <summary>
        ///     Gets the list of links (meaning and to)  for the currently selected thesaurus item, where the meaning is in the set
        ///     of conjugation values.
        /// </summary>
        [System.Xml.Serialization.XmlIgnore]
        public ThesaurusLinkedItems Conjugations
        {
            get
            {
                if (fConjugations == null && fSelectedItem != null)
                {
                    fConjugations = new ThesaurusLinkedItems(fSelectedItem.Item, ConjugationMeanings);
                    fConjugations.IsLoaded = IsSubItemsLoaded;
                }

                return fConjugations;
            }

            internal set
            {
                if (value != fConjugations)
                {
                    if (value == null && fConjugations != null)
                    {
                        // if we set the items to null, but there were still items assigned, we make certain that the collection is cleared cause this will unregister all the neurons with the eventmanager that the collection is monitorring.
                        fConjugations.Clear();
                    }

                    fConjugations = value;
                    if (fConjugations != null)
                    {
                        fConjugations.IsLoaded = IsSubItemsLoaded;
                    }
                }

                OnPropertyChanged("Conjugations");
            }
        }

        #endregion

        #region IsSubItemsLoaded

        /// <summary>
        ///     Gets/sets the wether the list of sub items is loaded or not.
        /// </summary>
        public bool IsSubItemsLoaded
        {
            get
            {
                return fIsSubItemsLoaded;
            }

            set
            {
                fIsSubItemsLoaded = value;
                if (fSubItems != null)
                {
                    fSubItems.IsLoaded = value;
                }

                if (fPOSRelated != null)
                {
                    fPOSRelated.IsLoaded = value;
                }

                if (fConjugations != null)
                {
                    fConjugations.IsLoaded = value;
                }

                if (value == false)
                {
                    TreeRowHeight = new System.Windows.GridLength(
                        TreeRowHeight.Value + SubItemsRowHeight.Value, 
                        System.Windows.GridUnitType.Star);
                }

                OnPropertyChanged("SubItemsRowHeight"); // just let it update the property.

                OnPropertyChanged("IsSubItemsLoaded");
            }
        }

        #endregion

        #region root

        /// <summary>
        ///     Gets the root of the thesaurus
        /// </summary>
        /// <value>The root.</value>
        [System.Xml.Serialization.XmlIgnore]
        public Thesaurus Root
        {
            get
            {
                return this;
            }
        }

        #endregion

        #region ThesHorScrollPos

        /// <summary>
        ///     Gets/sets the horizontal scrollpos of the thesaurus
        /// </summary>
        public double ThesHorScrollPos
        {
            get
            {
                return fThesHorScrollPos;
            }

            set
            {
                fThesHorScrollPos = value;
                OnPropertyChanged("ThesHorScrollPos");
            }
        }

        #endregion

        #region ThesVerScrollPos

        /// <summary>
        ///     Gets/sets the vertical scrollpos of the thesaurus.
        /// </summary>
        public double ThesVerScrollPos
        {
            get
            {
                return fThesVerScrollPos;
            }

            set
            {
                fThesVerScrollPos = value;
                OnPropertyChanged("ThesVerScrollPos");
            }
        }

        #endregion

        #region TreeRowHeight

        /// <summary>
        ///     Gets/sets the width of the first column in the UI, that contains the output patterns.
        /// </summary>
        public System.Windows.GridLength TreeRowHeight
        {
            get
            {
                return fTreeRowHeight;
            }

            set
            {
                fTreeRowHeight = value;
                OnPropertyChanged("TreeRowHeight");
            }
        }

        #endregion

        #region SubItemsRowHeight

        /// <summary>
        ///     Gets/sets the width of the second column in the UI, that contains the do patterns.
        /// </summary>
        public System.Windows.GridLength SubItemsRowHeight
        {
            get
            {
                if (IsSubItemsLoaded)
                {
                    return fSubItemsRowHeight;
                }

                return new System.Windows.GridLength(0);
            }

            set
            {
                if (IsSubItemsLoaded)
                {
                    // only store new values when visible. When not visible, keep the old one. If we don't do this, we reset the value when it is hidden/shown again.
                    fSubItemsRowHeight = value;
                    OnPropertyChanged("SubItemsRowHeight");
                }
            }
        }

        #endregion

        /// <summary>
        ///     Gets an object that allows a <see cref="DropDownNNSelector" /> to browse through the data of all the textpatterns
        ///     in the project.
        /// </summary>
        public System.Collections.IEnumerator BrowsableTextPatterns
        {
            get
            {
                return new ThesPatternEditorsEnumerator(this);
            }
        }

        /// <summary>
        ///     Gets an object that allows a <see cref="DropDownNNSelector" /> to browse through the thesaurus items.
        /// </summary>
        public System.Collections.IEnumerator BrowsableItems
        {
            get
            {
                return new ThesaurusEnumerator(this);
            }
        }

        #endregion

        #region Data

        /// <summary>Builds the list of Items. The list should be best be empty (no check is done).</summary>
        /// <param name="relationship">The relationship to find items for.</param>
        /// <param name="posFilter">The pos Filter.</param>
        /// <param name="list">The list to add the items to.</param>
        internal void BuildItems(
            Neuron relationship, 
            Neuron posFilter, System.Collections.Generic.IList<ThesaurusItem> list)
        {
            LargeIDCollection iFound;
            fLock.EnterReadLock();
            try
            {
                if (Data.TryGetValue(relationship.ID, out iFound))
                {
                    foreach (var i in iFound)
                    {
                        if (BrainData.Current.DesignerData != null)
                        {
                            // this is loaded async, the user might be fast and switch project. We need to be prepared for this.
                            var iItem = Brain.Current[i];
                            if (CheckFilter(iItem, posFilter))
                            {
                                list.Add(new ThesaurusItem(iItem, relationship));
                            }
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }
            finally
            {
                fLock.ExitReadLock();
            }
        }

        /// <summary>Builds the list of Items. The list should be best be empty (no check is done).</summary>
        /// <param name="relationship">The relationship to find items for.</param>
        /// <param name="posFilter">The pos Filter.</param>
        /// <param name="list">The list to add the items to.</param>
        internal void BuildItems(Neuron relationship, Neuron posFilter, System.Collections.Generic.IList<Neuron> list)
        {
            if (relationship != null)
            {
                // can be with a completely empty thesaurus.
                LargeIDCollection iFound;
                fLock.EnterReadLock();
                try
                {
                    if (Data.TryGetValue(relationship.ID, out iFound))
                    {
                        foreach (var i in iFound)
                        {
                            if (BrainData.Current.DesignerData != null)
                            {
                                // this is loaded async, the user might be fast and switch project. We need to be prepared for this.
                                var iItem = Brain.Current[i];
                                if (CheckFilter(iItem, posFilter))
                                {
                                    list.Add(iItem);
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                }
                finally
                {
                    fLock.ExitReadLock();
                }
            }
        }

        /// <summary>Gets the neuronCluster associated with the id, if it is valid for the currently selected POS filter.
        ///     Uses the first relationhip as the one to search for pos values.</summary>
        /// <param name="item">The item.</param>
        /// <param name="posFilter">The pos Filter.</param>
        /// <returns>The <see cref="bool"/>.</returns>
        private bool CheckFilter(Neuron item, Neuron posFilter)
        {
            var iPosFilter = posFilter;
            if (iPosFilter != null)
            {
                var iRes = item as NeuronCluster;
                if (iRes != null)
                {
                    Neuron iFound;
                    if (Relationships.Count > 0)
                    {
                        iFound = BrainHelper.GetPosFor(iRes, Relationships[0].Item);

                            // the first relationship is the 'is a', who's path can be used to find a parent that defines the pos value.
                    }
                    else
                    {
                        iFound = BrainHelper.GetPosFor(iRes, null);
                    }

                    if (iFound != iPosFilter)
                    {
                        return false;
                    }
                }
                else if (item != null)
                {
                    LogService.Log.LogError(
                        "Thesaurus.BuildItems", 
                        string.Format(
                            "can't add Neuron {0} to thesaurus because it is not a cluster, there might be some data inconsistency!", 
                            item.ID));
                    return false;
                }
            }

            return true;
        }

        /// <summary>This is called when the pos. Note: this will be called from another thread as the ui, so any list changes need to
        ///     go through
        ///     the ui dispatcher, otherwise the ui doesn't see the change.</summary>
        /// <param name="item">The item.</param>
        internal void UpdateForFilter(ThesaurusItem item)
        {
            if (CheckFilter(item.Item, SelectedPOSFilter) == false)
            {
                System.Windows.Application.Current.Dispatcher.BeginInvoke(
                    System.Windows.Threading.DispatcherPriority.Normal, 
                    new System.Func<ThesaurusItem, bool>(Items.Remove), 
                    item);
            }
        }

        #endregion

        #region IWeakEventListener Members

        /// <summary>Receives events from the centralized event manager.</summary>
        /// <param name="managerType">The type of the <see cref="T:System.Windows.WeakEventManager"/> calling this method.</param>
        /// <param name="sender">Object that originated the event.</param>
        /// <param name="e">Event data.</param>
        /// <returns>true if the listener handled the event. It is considered an error by the<see cref="T:System.Windows.WeakEventManager"/> handling in WPF to register a listener for an event that the
        ///     listener does not handle. Regardless, the method should return false if it receives an event that it does not
        ///     recognize or handle.</returns>
        public bool ReceiveWeakEvent(System.Type managerType, object sender, System.EventArgs e)
        {
            if (managerType == typeof(NewRootEventManager))
            {
                System.Windows.Application.Current.Dispatcher.BeginInvoke(
                    System.Windows.Threading.DispatcherPriority.Normal, 
                    new System.Action<NewRootEventArgs>(HandleNewRoot), 
                    e);
                return true;
            }

            if (managerType == typeof(RelationshipTypeCreatedEventManager))
            {
                System.Windows.Application.Current.Dispatcher.BeginInvoke(
                    System.Windows.Threading.DispatcherPriority.Normal, 
                    new System.Action<NewMetaTypeEventArgs>(HandleNewRelationship), 
                    e);
                return true;
            }

            return false;
        }

        /// <summary>Called when wordnetsin creates a new object that should be added as a root of the thesaurus.
        ///     Check if root not already added, if so, add.</summary>
        /// <param name="e">The <see cref="JaStDev.HAB.NewRootEventArgs"/> instance containing the event data.</param>
        private void HandleNewRoot(NewRootEventArgs e)
        {
            if (e.PossibleOtherRoot == null)
            {
                AddRootItem(e.Relationship, e.Item);
            }
            else
            {
                AddPossibleRoot(e);
            }
        }

        /// <summary>Checks if the other item isn't a root, if not, the item is added as root for the specified relationship.</summary>
        /// <param name="e"></param>
        private void AddPossibleRoot(NewRootEventArgs e)
        {
            LargeIDCollection iRoots;
            fLock.EnterWriteLock();
            try
            {
                if (Data.TryGetValue(e.Relationship.ID, out iRoots) == false)
                {
                    iRoots = InternalCreateRelationship(e.Relationship); // need to prevent a recursive lock.
                }

                if (iRoots.Contains(e.Item.ID) == false && iRoots.Contains(e.PossibleOtherRoot.ID) == false)
                {
                    iRoots.Add(e.Item.ID);
                    if (SelectedRelationship == e.Relationship && InternalItems != null)
                    {
                        // only try to add it to the UI data list when there is data loaded and visible.
                        if (CheckFilter(e.Item, SelectedPOSFilter))
                        {
                            InternalItems.Add(new ThesaurusItem(e.Item, e.Relationship));

                                // we need to use the 'itemsDirect call
                        }
                    }
                }
            }
            finally
            {
                fLock.ExitWriteLock();
            }
        }

        /// <summary>Adds the specified item as a new root for the specified relationship.</summary>
        /// <param name="relationship">The relationship.</param>
        /// <param name="toAdd">To add.</param>
        public void AddRootItem(Neuron relationship, Neuron toAdd)
        {
            LargeIDCollection iRoots;
            fLock.EnterWriteLock();
            try
            {
                if (Data.TryGetValue(relationship.ID, out iRoots) == false)
                {
                    iRoots = InternalCreateRelationship(relationship); // need to prevent a recursive lock.
                }

                if (iRoots.Contains(toAdd.ID) == false)
                {
                    iRoots.Add(toAdd.ID);
                    if (SelectedRelationship == relationship && InternalItems != null)
                    {
                        // only try to add it to the UI data list when there is data loaded and visible.
                        if (CheckFilter(toAdd, SelectedPOSFilter))
                        {
                            InternalItems.Add(new ThesaurusItem(toAdd, relationship));

                                // we need to use the 'itemsDirect call
                        }
                    }
                }
            }
            finally
            {
                fLock.ExitWriteLock();
            }
        }

        /// <summary>Removes the specified item as a root for the specified relationship.</summary>
        /// <param name="relationship">The relationship.</param>
        /// <param name="toRemove">The to Remove.</param>
        public void RemoveRootItem(Neuron relationship, Neuron toRemove)
        {
            fLock.EnterWriteLock();
            try
            {
                LargeIDCollection iRoots;
                if (Data.TryGetValue(relationship.ID, out iRoots))
                {
                    iRoots.Remove(toRemove.ID);
                    if (SelectedRelationship == relationship)
                    {
                        var iFound = (from i in Items where i.Item == toRemove select i).FirstOrDefault();
                        if (iFound != null)
                        {
                            Items.Remove(iFound);
                        }
                    }
                }
            }
            finally
            {
                fLock.ExitWriteLock();
            }
        }

        /// <summary>Event handler for wordnet sin. called when a new relationship object is created.</summary>
        /// <param name="e">The <see cref="JaStDev.HAB.NewMetaTypeEventArgs"/> instance containing the event data.</param>
        private void HandleNewRelationship(NewMetaTypeEventArgs e)
        {
            if (e.IsRecursive == false && e.Name != "similar" && e.Name != "also")
            {
                // recursive relationships are handled when the root is created, which is faster for them.  Non recursive relationships need to be handled speratetly. similar and also are non recursive, but should better be treated as recursive, therer is a parent child relationship. this way, there are more roots for adj,...
                if (Data.ContainsKey(e.Neuron.ID) == false)
                {
                    // only add nonrecursive relationhip if it isn't already defined as recursive, which has presedence..
                    var iNew = new ThesaurusRelItem(e.Neuron);
                    NoRecursiveRelationships.Add(iNew);
                }
            }
        }

        /// <summary>Recreates a relationship for the undo system.</summary>
        /// <param name="id">The id.</param>
        /// <param name="data">The data.</param>
        public void RecreateRelationship(ulong id, LargeIDCollection data)
        {
            fLock.EnterWriteLock();
            try
            {
                Data.Add(id, data);
                Relationships.Add(new ThesaurusRelItem(Brain.Current[id]));
            }
            finally
            {
                fLock.ExitWriteLock();
            }
        }

        /// <summary>Creates a new relationship and adds it to the data dict.</summary>
        /// <param name="neuron">The neuron.</param>
        /// <returns>The <see cref="LargeIDCollection"/>.</returns>
        public LargeIDCollection CreateRelationship(Neuron neuron)
        {
            fLock.EnterWriteLock();
            try
            {
                return InternalCreateRelationship(neuron);
            }
            finally
            {
                fLock.ExitWriteLock();
            }
        }

        /// <summary>Thread unsafe version of <see cref="Thesaurus.CreateRelationship"/>
        ///     also makes certain that the item isn't registered as non recursive + added to the WordNetRelationships list</summary>
        /// <param name="neuron">The neuron.</param>
        /// <returns>The large id list created for the normal data collection.</returns>
        private LargeIDCollection InternalCreateRelationship(Neuron neuron)
        {
            var iRes = new LargeIDCollection();
            Data.Add(neuron.ID, iRes);
            var iFound = (from i in NoRecursiveRelationships where i.Item == neuron select i).FirstOrDefault();
            if (iFound != null)
            {
                NoRecursiveRelationships.Remove(iFound);
            }

            var iRels = Brain.Current[(ulong)PredefinedNeurons.WordNetRelationships] as NeuronCluster;
            if (iRels != null)
            {
                // also need to add to the 'relationships list', so the system can quickly find which it's known relationships are.
                using (var iList = iRels.ChildrenW) iList.Add(neuron);
            }

            if (System.Threading.Thread.CurrentThread == System.Windows.Application.Current.Dispatcher.Thread)
            {
                // when converting a project to new format, we update the thesaurus from another thread. This call can cause problems if we don't make certain that it goes to the Ui thread
                Relationships.Add(new ThesaurusRelItem(neuron));
            }
            else
            {
                System.Windows.Application.Current.Dispatcher.BeginInvoke(
                    new System.Action<ThesaurusRelItem>(Relationships.Add), 
                    new ThesaurusRelItem(neuron));
            }

            return iRes;
        }

        #endregion

        #region thesaurus relationship

        /// <summary>Creates a relationship between the 2 neurons with the specified relationship using the wordnet structure, with undo
        ///     data.</summary>
        /// <remarks><para>If the 'from' neuron already has a link to a cluster for the specified relationship, the item is simply added,
        ///         otherwise, a new cluster is created for the relationship and the item is added.
        ///         If the item is already in the list, it is not added again.</para>
        /// <para>Doesn't trigger any wordnet events (regular brain events are triggered like normal).</para>
        /// <para>To remove a thesaurus relationship, use <see cref="WordNetSin.RemoveRelationship"/></para>
        /// </remarks>
        /// <param name="start">From part of pseudo link.</param>
        /// <param name="to">To part of pseudo link.</param>
        /// <param name="relationship">The meaning part of pseudo link.</param>
        public static void CreateRelationship(Neuron start, Neuron to, Neuron relationship)
        {
            NeuronCluster iFound = null;
            if (start.LinksOutIdentifier != null)
            {
                var iLinks = Factories.Default.LinkLists.GetBuffer();
                try
                {
                    using (var iList = start.LinksOut) iLinks.AddRange(iList);
                    iFound = (from i in iLinks
                              let iCluster = i.To as NeuronCluster
                              where i.MeaningID == relationship.ID && iCluster.Meaning == relationship.ID
                              select iCluster).FirstOrDefault();
                }
                finally
                {
                    Factories.Default.LinkLists.Recycle(iLinks);
                }
            }

            if (iFound == null)
            {
                iFound = NeuronFactory.GetCluster();
                iFound.Meaning = relationship.ID;
                WindowMain.AddItemToBrain(iFound);
                var iLink = new Link(iFound, start, relationship);
                var iLinkUndo = new LinkUndoItem(iLink, BrainAction.Created);
                WindowMain.UndoStore.AddCustomUndoItem(iLinkUndo);
            }

            var iChildren = iFound.ChildrenW;
            iChildren.Lock(to);
            try
            {
                if (iChildren.ContainsUnsafe(to) == false)
                {
                    var iClusterUndo = new AddClusterUndoItem();
                    iClusterUndo.Items = new System.Collections.Generic.List<Neuron> { to };
                    iClusterUndo.Cluster = iFound;
                    WindowMain.UndoStore.AddCustomUndoItem(iClusterUndo);
                    iChildren.AddUnsafe(to);
                }
            }
            finally
            {
                iChildren.Unlock(to);
                iChildren.Dispose();
            }
        }

        /// <summary>Creates a new relationship and adds it to the data dict.</summary>
        /// <param name="id">The id.</param>
        public void RemoveRelationship(ulong id)
        {
            fLock.EnterWriteLock();
            try
            {
                InternalRemoveRelationship(id);
            }
            finally
            {
                fLock.ExitWriteLock();
            }
        }

        /// <summary>Thread unsafe version of <see cref="Thesaurus.CreateRelationship"/></summary>
        /// <param name="id">The id.</param>
        private void InternalRemoveRelationship(ulong id)
        {
            Data.Remove(id);

            var i = 0;
            while (i < Relationships.Count)
            {
                if (Relationships[i].Item.ID == id)
                {
                    Relationships.RemoveAt(i);
                    break;
                }

                i++;
            }
        }

        /// <summary>Removes a relationship between the 2 neurons, using the specified relationship neuron, in a manner consistent with
        ///     the thesaurus and with undo data. (so this is is for removing thesaurus relationships).</summary>
        /// <remarks>When a relationship is removed, we currently don't remove the ns yet.  needs checking.</remarks>
        /// <param name="start">The start.</param>
        /// <param name="to">To.</param>
        /// <param name="relationship">The relationship.</param>
        public void RemoveRelationship(Neuron start, Neuron to, Neuron relationship)
        {
            NeuronCluster iFound = null;
            if (start.LinksOutIdentifier != null)
            {
                var iLinks = Factories.Default.LinkLists.GetBuffer();
                try
                {
                    using (var iList = start.LinksOut) iLinks.AddRange(iList);
                    iFound = (from i in iLinks
                              let iCluster = i.To as NeuronCluster
                              where i.MeaningID == relationship.ID && iCluster.Meaning == relationship.ID
                              select iCluster).FirstOrDefault();
                }
                finally
                {
                    Factories.Default.LinkLists.Recycle(iLinks);
                }
            }

            if (iFound != null)
            {
                var iClusterUndo = new RemoveClusterUndoItem();
                iClusterUndo.Items = new System.Collections.Generic.List<Neuron> { to };
                iClusterUndo.Cluster = iFound;
                WindowMain.UndoStore.AddCustomUndoItem(iClusterUndo);
                using (var iList = iFound.ChildrenW)
                {
                    iList.Remove(to); // this locks the list.
                    if (iList.Count == 0)
                    {
                        // new lock. don't needto be in the same lock.
                        var iNeuronUndo = new NeuronUndoItem();
                        iNeuronUndo.Action = BrainAction.Removed;
                        iNeuronUndo.Neuron = iFound;
                        WindowMain.UndoStore.AddCustomUndoItem(iNeuronUndo);
                        Brain.Current.Delete(iFound);
                    }
                }
            }
        }

        /// <summary>Determines whether the specified item to check, still has any thesaurus relationships.</summary>
        /// <remarks>not used at the moment. (was used for namespaces)</remarks>
        /// <param name="toCheck">Item to check.</param>
        /// <returns><c>true</c> if it has thesaurus relationships; otherwise, <c>false</c>.</returns>
        public bool HasThesaurusRelationships(Neuron toCheck)
        {
            var iRels = (from i in Relationships select i.Item.ID).ToList();

                // we need the id's to compare with the links and clusters, so get the list 1 time.
            var iNRels = (from i in NoRecursiveRelationships select i.Item.ID).ToList();
            {
                using (var iList = toCheck.LinksOut)
                {
                    var iFound =
                        (from i in iList where iRels.Contains(i.MeaningID) || iNRels.Contains(i.MeaningID) select i)
                            .FirstOrDefault();
                    if (iFound != null)
                    {
                        return true;
                    }
                }
            }

            if (toCheck.ClusteredByIdentifier != null)
            {
                using (var iList = toCheck.ClusteredBy)
                {
                    var iFound =
                        (from i in toCheck.ClusteredBy where iRels.Contains(i) || iNRels.Contains(i) select i).ToList();
                    if (iFound.Count > 0)
                    {
                        return true;
                    }
                }
            }

            // first, check if there are any outgoing links with one of the recursive or non recursiv relationships.
            if (toCheck.LinksInIdentifier != null)
            {
                using (var iList = toCheck.LinksIn)
                {
                    var iFound =
                        (from i in iList where iRels.Contains(i.MeaningID) || iNRels.Contains(i.MeaningID) select i)
                            .FirstOrDefault();
                    if (iFound != null)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        #endregion

        #region IXmlSerializable Members

        /// <summary>
        ///     This method is reserved and should not be used. When implementing the IXmlSerializable interface, you should return
        ///     null (Nothing in Visual Basic) from this method, and instead, if specifying a custom schema is required, apply the
        ///     <see cref="T:System.Xml.Serialization.XmlSchemaProviderAttribute" /> to the class.
        /// </summary>
        /// <returns>
        ///     An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is
        ///     produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method
        ///     and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />
        ///     method.
        /// </returns>
        public System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }

        /// <summary>Generates an object from its XML representation.</summary>
        /// <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
        public void ReadXml(System.Xml.XmlReader reader)
        {
            fLock.EnterWriteLock();
            try
            {
                var wasEmpty = reader.IsEmptyElement;

                reader.Read();
                if (wasEmpty)
                {
                    return;
                }

                if (reader.Name == "Data")
                {
                    var iData = new Data.SerializableDictionary<ulong, LargeIDCollection>();
                    iData.ReadXml(reader);
                    Data = iData;
                }
                else
                {
                    fData = new Data.SerializableDictionary<ulong, LargeIDCollection>();

                        // don't set data, this does to much: try to extract relationships out of dict, which is not required.
                    fRelationships = new ThesaurusRelItemCollection();
                    
                    fRelationships.ReadXml(reader);
                }

                var iTemp = -1;
                if (XmlStore.TryReadElement(reader, "SelectedRelationshipIndex", ref iTemp))
                {
                    fSelectedRelationshipIndex = iTemp;

                        // set to field, otherwise we have a deadlock: setting the prop rebuilds the lists, which requests a read lock, can't have recursive (don't want to).
                }

                NoRecursiveRelationships = new ThesaurusRelItemCollection();
                if (reader.Name == "NoRecursiveRelationships")
                {
                    NoRecursiveRelationships.ReadXml(reader);
                }

                if (reader.Name == "PosFilters")
                {
                    // if there is still a posfilter list stored in the data, skip this, we use a default/fixed list of part of speech neurons
                    var iPosFilters = new ThesaurusRelItemCollection();
                    iPosFilters.ReadXml(reader);
                }

                if (reader.Name == "Conjugations")
                {
                    // This is new, so could be not present.
                    ConjugationMeanings.ReadXml(reader);
                }

                if (XmlStore.TryReadElement(reader, "SelectedPosFilterIndex", ref iTemp))
                {
                    fSelectedPosFilterIndex = iTemp;

                        // set to field, otherwise we have a deadlock: setting the prop rebuilds the lists, which requests a read lock, can't have recursive (don't want to).
                }

                var iBool = false;
                if (XmlStore.TryReadElement(reader, "IsSubItemsLoaded", ref iBool))
                {
                    IsSubItemsLoaded = iBool;
                }

                reader.ReadEndElement();
            }
            finally
            {
                fLock.ExitWriteLock();
            }
        }

        /// <summary>Converts an object into its XML representation.</summary>
        /// <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized.</param>
        public void WriteXml(System.Xml.XmlWriter writer)
        {
            fLock.EnterReadLock(); // need to lock to prevent the change in the relationships list.
            try
            {
                // can't safe the data, this is done externally, to make certain that a thesaurus can be saved to different places than only the current project location.
                writer.WriteStartElement("Relationships");
                Relationships.WriteXml(writer);
                writer.WriteEndElement();
                XmlStore.WriteElement(writer, "SelectedRelationshipIndex", SelectedRelationshipIndex);

                writer.WriteStartElement("NoRecursiveRelationships");
                NoRecursiveRelationships.WriteXml(writer);
                writer.WriteEndElement();

                writer.WriteStartElement("Conjugations");
                ConjugationMeanings.WriteXml(writer);
                writer.WriteEndElement();

                XmlStore.WriteElement(writer, "SelectedPosFilterIndex", SelectedPosFilterIndex);
                XmlStore.WriteElement(writer, "IsSubItemsLoaded", IsSubItemsLoaded);
            }
            finally
            {
                fLock.ExitReadLock();
            }
        }

        #endregion

        #region IOnCascadedChanged Members

        /// <summary>Raises the <see cref="E:CascadedCollectionChanged"/> event. (used to display the treeview).</summary>
        /// <param name="args">The <see cref="JaStDev.Data.CascadedCollectionChangedEventArgs"/> instance containing the event
        ///     data.</param>
        public void OnCascadedCollectionChanged(Data.CascadedCollectionChangedEventArgs args)
        {
            if (fBuildingList == false && CascadedCollectionChanged != null)
            {
                // while we are building this list (async), don't raise any events, this only breaks the UI, would slow it down and is not needed.
                CascadedCollectionChanged(this, args);
            }
        }

        /// <summary>Raises the <see cref="E:CascadedPropertyChanged"/> event. (used to display the treeview).</summary>
        /// <param name="args">The <see cref="JaStDev.Data.CascadedPropertyChangedEventArgs"/> instance containing the event data.</param>
        public void OnCascadedPropertyChanged(Data.CascadedPropertyChangedEventArgs args)
        {
            if (CascadedPropertyChanged != null)
            {
                CascadedPropertyChanged(this, args);
            }
        }

        #endregion
    }
}